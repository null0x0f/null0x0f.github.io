---
abbrlink: 1db60101
title: OPERATING SYSTEM
---
# Computer Operating System
## 导论
cs ->  hardware(io cpu...)   software(application)   data
![计算机系统层次结构.png](https://img1.imgtp.com/2023/09/06/d78muiI5.png)

### interface(接口)
hard - hard       example： USB   
soft - hard    操作系统通过instructions(指令集)      example: printf() API接口
### Virtual Machine
操作系统向用户提供一个容易理解和使用的计算机（虚拟的），用户对这个计算机操作将被操作系统转换成对计算机硬件的操作
![virtualmachine.png](https://img1.imgtp.com/2023/09/06/RRCokhXB.png)
## 计算机系统组成
CPU RAM DISK  IOdevice .....

### 中断
当所有事情发生时，CPU收到一个中断信号
CPU停下来正在做的事，转而执行中断处理程序，执行完毕会回到之前被中断的地方继续执行
操作系统是一个以中断驱动的系统
### 存储系统
cpu负责将指令从内存读入，所以程序必须在内存中才能运行
内存以字节为存储单位，每个字节都有一个地址与之对应，通过load/store指令可以访问指定地址的内存数据
load：将内存数据装入寄存器(Register)
store:将寄存器数据写入内存
![memory.png](https://img1.imgtp.com/2023/09/06/5VWEg8O2.png)

### I/O结构
![IO.png](https://img1.imgtp.com/2023/09/06/ILOc6hv1.png)
## 系统体系结构
### 单处理器系统
![单处理.png](https://img1.imgtp.com/2023/09/06/7zwB9zof.png)
### 多处理系统
两个或多个CPU
非对称处理
对称处理
### 集群系统    ->cloud computing  云计算
若干节点，多台计算机通过网络连接在一起,节点之间是松耦合关系
高可用
高性能计算

## 操作系统结构
### 单用户单道模式
### 多道程序设计
让CPU总有一个执行任务
### 分时系统(多任务系统)
多个用户共享一天计算机
分时系统为每个用户轮流分配等量的CPU时间
发出指令到即时结果的时间为响应时间
### 提供服务 
![操作系统提供服务.png](https://img1.imgtp.com/2023/09/06/S1Yj9gCu.png)
user interface 面向user
CLI   GUI   Batch
system calls 面向开发者
![标准c程序.png](https://img1.imgtp.com/2023/09/06/h7zkE4Ho.png)
usermode:执行用户代码
kernelmode:执行os代码
目的：确保os正确运行
实现方式：0表示kernel模式 1表示user模式
![trap.png](https://img1.imgtp.com/2023/09/06/jjIYKRgM.png)
## process Concept
### definition
#### process in memory
![process in memory.png](https://img1.imgtp.com/2023/09/23/UynqM9y7.png)
#### concurrency
![并发进程共享cpu.png](https://img1.imgtp.com/2023/09/06/78238sf4.png)
进程是一个程序的一次执行过程
进程是资源分配，保护和调度的基本单位
### PROCESS STATE
Running:此时进程的代码在cpu上运行
Ready:进程具备运行条件，等待分配cpu
Waiting:进程在等待某些时间的发生
![进程状态转换.png](https://img1.imgtp.com/2023/09/06/9TDwauXR.png)## process scheduling
### 进程切换
切换时机：
进入等待状态
进程被抢占CPU而进入就绪状态


切换过程：
保存被中断进程的上下文信息
修改被中断进程的控制信息
将被中断的进程加入相应的状态队列
调度一个新的进程并恢复他的上下文信息
#### 中断技术 
当发生某个异常事件，中止cpu上现行程序的运行
引出该事件的处理程序执行
执行完毕返回中断点继续执行
##### 外中断
来自cpu外部
异步中断（随机）
##### 内中断
硬件，程序异常，系统调用
##### 中断处理过程
context:save the context of the excuting process
![中断处理过程.png](https://img1.imgtp.com/2023/09/06/3EwqIMGY.png)
#### 特权指令和非特权指令
privileged instructions: only in kernel mode process switch
non - privileged instructions: only in usermode
#### 进程控制块
![进程控制块.png](https://img1.imgtp.com/2023/09/06/SwnDGm62.png)
###  进程队列
![进程队列.png](https://img1.imgtp.com/2023/09/06/qnq618S1.png)
### 进程调度
![进程调度.png](https://img1.imgtp.com/2023/09/06/Sv8dRAZb.png)
### 实验（创建子进程）
getpid:返回当前进程的id
wait(NULL)
## THREAD
### motivation
实现并行，把所有执行流封装到一个进程里
执行流（线程）
### merit 
响应性
资源共享
经济
可伸缩性
### DEFINITION
### Multithreading Model
#### 用户线程
ULT在user mode下运行
#### 内核线程
KLT在kernel mode下运行，由操作系统支持和管理

#### M：1模型
![M1.png](https://img1.imgtp.com/2023/09/23/31PavFWG.png)
优：逻辑上提供了多个执行流
缺：实际上并不是并行，只占用了一个KLT
#### 1：1模型
优：并发加并行
缺：空间和时间内核开销
#### M:M模型
优：开销减小
缺：实现复杂
### 多核编程
![多核编程.png](https://img1.imgtp.com/2023/09/23/446RpHPO.png)
### 多线程实验
```
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <pthread.h>
int value = 100;//共享数据部分属于进程
void* hello(void* arg)
{
   for(int i = 0;i<3;i++)
   {
      printf("hello(%d)",value);
      sleep(1);
   }
}
void* world(void* arg)
{
for(int i = 0;i<3;i++)
   {
      printf("world(%d)",value);
      sleep(3);
   }
}
int main()
{
   thread_t tid1,tid2;
   //线程创建函数
   //1.第一个参数传线程id地址
   //2.第二个参数传线程分配地址
   //3.第三个参数传线程函数地址
   //4.第四个参数传线程参数地址
   pthread_create(&tid1,NULL,hello,NULL);
   pthread_create(&tid2,NULL,hello,NULL);
   //等待指定线程结束
   pthread_join(tid1,NULL);
   pthread_join(tid2,NULL);
   printf("in main thread(%d)",value);
}
```
所有线程共享数据段
线程中局部变量是没用办法在另外一个线程中访问的,局部变量属于线程中自己的栈
线程是并发执行的

等待线程结束的原因（thread_join）：
![多线程实验1.png](https://img1.imgtp.com/2023/09/23/7SZd3hzg.png)

实验中Linux命令：
编译多线程文件
gcc   ****.c  -o  **** -pthread 
time 命令获取程序在cpu，用户，实际运行时所需要的时间 


![多线程实验2.png](https://img1.imgtp.com/2023/09/23/DntcGij8.png)
```c
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <pthread.h>
#include<time.h>
#include<stdlib.h>
void* Caculate(void* arg)
{ 
  unsigned seed = time(NULL);
   int circle_point = 0;
   int square_point = 0;
   int value = *((int*)arg);
   for(int i = 0;i<value*value;i++)
   {
      double rand_x = (double)rand_r(&seed)/RAND_MAX;
      double rand_y = (double)rand_r(&seed)/RAND_MAX;
      if(rand_x*rand_x+rand_y*rand_y<=1)
      {
        circle_point++;
      }
      square_point++;
   }
   double PI = (4.0*circle_point)/square_point;
   printf("PI=%lf in %d times \n",PI,value*value); 
   
}
int main()
{
   int args[10];
   clock_t delta;
   clock_t start = clock();
   pthread_t calculate_pi_thread[10];
   for(int i = 0;i<10;i++)
   {
     args[i] = 100+i;
     pthread_create(calculate_pi_thread+i,NULL,Caculate,args+i);
   }
   for(int i = 0;i<10;i++)
   {
      pthread_join(calculate_pi_thread[i],NULL);
   }
   delta = clock()-start;
   printf("total time is %lf\n",(double)delta/CLOCKS_PER_SEC);
   return 0;
}
```
## LECTURE 6 CPU SCHEDULING
### CPU调度程序   基于单处理器
长进程：占用cpu时间长
短进程：占用cpu时间短
CPU bonding ： cpu占用密集
IO  .....     : 
非抢占调度：一个进程占用cpu直到进程中断或结束
抢占调度(Preemptive scheduling): 
调度算法性能的衡量：
![调度算法.png](https://img1.imgtp.com/2023/09/23/mMpt1hI9.png)
### 调度性能指标
ti = tf - ts;（进程提交给系统的时刻是ts，完成时刻是tf）
### 调度算法
#### FCFS(队列)
![FCFS.png](https://img1.imgtp.com/2023/09/23/6zHTmmot.png)
#### 时间片轮转（TIME SHARING）
![时间片轮转.png](https://img1.imgtp.com/2023/09/23/MxEE0YpC.png)                  
算法分析：
时间片选取：
取值太小： 进程切换开销太大
取值太大：响应速度下降
选区范围：10ms-100ms

对长作业切换开销太大
### 最短作业优先（SJF）
下一次调度选择所需要的CPU时间最短的那个进程
![SRTF.png](https://img1.imgtp.com/2023/09/23/4Tlt60Xq.png)
长进程可能长时间无法获取CPU
很难实现：该算法需要事先知道进程所需CPU时间
### 优先级调度
调度策略：下次调度总是选择优先级最高的进程
#### 优先级定义
在Linux中，线程调度优先级由一个整数值表示，范围从0到最高优先级（通常是99）。较高的优先级值表示线程具有更高的优先级。

静态优先级：优先级保持不变，但会出现不公平现象
动态优先级：根据proess占用CPU时间：当进程占用CPU时间越长，慢慢降低优先级
   根据进程等待：进程在就绪队列中等待时间越长，就慢慢提升优先级
          
### 调度
![调度.png](https://img1.imgtp.com/2023/09/23/dAMPp0J4.png)
## Linux 线程调度
```
pthread_attr_t attr  //初始化线程属性为默认

```
### 1.Scope:
PTHREAD_SCOPE_SYSTEM 系统 scs  Linux 一对一模型 
PTHREAD_SCOPE_PROCESS 进程 pcs 
### 2.调度策略，调度优先级
Scheduling policy :
NORMAL :    SHED_OTHER  ,SCHEO_IDLE ,   SCHED_BATCH,
REAL TIME:   SCHED_FIFO  ,   SCHED_RR 
实时的线程总是比普通线程优先级更高

SCHED_OTHER:  time -sharing   NICE:友好值[-20,19]   PR = 20+NICE[0,39]   PR值越高，优先级越低

REAL TIME :PR = -1 - proirity_value

PR:  rt -->  PR = -100

'chrt - p pid'->观察进程调度策略以及他的priority_value
'sudo chrt -f -p || pid' => 将皮带进程切换为rt并且设置其 priority_value和policy


## 调度策略的过程
![调度策略.png](https://img1.imgtp.com/2023/09/23/7CthWl6E.png)



## LECTURE 7 进程同步
### 并发
在内存中存在若干进程或线程，由操作系统的调度程序采用适当策略将他们调度到CPU上运行，同时维护他们的状态队列

并发是交替执行
宏观上是同时运行
微观上是走走停停的

并发进程关系：
独立
交互：竞争和协作

### 异步
1.random
2.![异步.png](https://img1.imgtp.com/2023/09/23/wk5gClpL.png)
3.![异步2.png](https://img1.imgtp.com/2023/09/23/XRziAQCU.png)

可能是图中情况，也可能是先执行完t1再执行t2
### 同步
维护数据的一致性  数据（协作或交互的进程）

Mutex lock （互斥锁）解决竞争问题
semaphore（信号量）解决协作问题



## 互斥锁
### 进程进出临界区协议
进入临界区前在entry section要请求许可
离开临界区后在exit section要归还许可

管理准则：
Mutual exclusion:互斥
Progress:前进
Bounded waiting：有限等待

1.section中有位置就必须进去一个
2.多个进程只能进去一个，其他进程等待
3.等待时间不能无限
4.在临界区里进程不能无限在临界区



测试：y->获得锁   n-> waiting

上锁和测试不能被打断

### 原子操作
test_and_set()
compare _and_swap()
### busy waiting（自旋锁）
占用CPU执行空循环进行等待
浪费CPU时间
进程在等待时没有上下文切换
```
//锁初始化
pthread_mutex_t lock = PTHREAD_MUTEX_INTIALIZER
//获取锁
pthread_mutex _lock(&lock)
//释放锁
pthread_mutex_unlock(&lock)
```



## SIGNAL （信号量）
PV操作
P:  wait()
V:  signal()

### 信号量的实现
```
P(s)
{
 while(s<=0)
 do noing;
 s--;
}

V(s)
{
 s++;
}
```
s<=0  P(s) :busy waiting   V(s) :s++
s=1    P(s)  :s=0    V(s): s = 2

### 信号量的使用
BINARY SEMAPHORE
二值信号量只能是0或1，通常将其初始化为1
```
semaphore mutex = 1;
process p
{
P(mutex);
   critical section

V(mutex)
}
```
COUNTING SEMAPHORE
一般信号量的取值可以是任意数值
```
semaphore road = 2;
process Car
{
  p(road);
   pass the fork
   in the road
  V(road);
}
```
s=1->竞争
s>1->可用资源数量

### Lab
![信号量lab.png](https://img1.imgtp.com/2023/09/23/qtjrx53O.png)
sem_wait()---->P()
sem_post()------->V()
