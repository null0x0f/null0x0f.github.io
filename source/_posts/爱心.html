<!DOCTYPE html>
<html lang="en">
 
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<style>
  * {
    margin: 0;
    padding: 0
  }
 
  html,
  body {
    height: 100%;
    padding: 0;
    margin: 0;
    background: #000;
  }
h5{
  position: relative;
font-size:60px;
  left: 25px;
                top: 50px;
 
} 
  canvas {
    width: 100%;
    height: 100%;
  }
  h5 {
    position: relative;
    font-size: 60px;
    left: 25px;
    top: 50px;
    color: #fff;
    z-index: 1;
  }
  .text-container {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    z-index: 1;
  }
  .text-container h6
 {
    font-size: 60px;
    color: pink;
  }
</style>
 
<body>
  <canvas></canvas>
  <div class="text-container">
    <h6>小蓓蓓</h6>
  </div>
  <script>
    const settings = {
      particles: {
      length: 1000, // 最大粒子数
        duration: 4, // 粒子持续时间
        velocity: 60, // 粒子速度
        effect: -0.45, // play with this for a nice effect
        size: 4, // 粒子大小
      }
    }
 
    let Point = (function () {
      function Point(x, y) {
        this.x = (typeof x !== 'undefined') ? x : 0;
        this.y = (typeof y !== 'undefined') ? y : 0;
      }
      Point.prototype.clone = function () {
        return new Point(this.x, this.y);
      };
      Point.prototype.length = function (length) {
        // 不传length length = 开方（x的平方 + y平方） 
        if (typeof length == 'undefined')
          return Math.sqrt(this.x * this.x + this.y * this.y);
 
        // 传length 求x，y
        this.normalize();
        this.x *= length;
        this.y *= length;
        return this;
      };
      Point.prototype.normalize = function () {
        // 已知length x，y为比例，求实际x，y
        let length = this.length();
        this.x /= length;
        this.y /= length;
        return this;
      };
      return Point;
    })();
 
    function pointOnHeart(t) {
      // -PI <= t <= PI    心形完整度
      return new Point(
        160 * Math.pow(Math.sin(t), 3),
        130 * Math.cos(t) - 50 * Math.cos(2 * t) - 20 * Math.cos(3 * t) - 10 * Math.cos(4 * t) + 25
      )
    }
    
    // 创建一个心
    let image = (function () {
      let canvas = document.createElement('canvas')
      let ctx = canvas.getContext('2d')
      canvas.width = settings.particles.size;
      canvas.height = settings.particles.size;
 
 
      // 帮助创建路径函数
      function to(t) {
        let point = pointOnHeart(t);
        point.x = settings.particles.size / 2 + point.x * settings.particles.size / 350;
        point.y = settings.particles.size / 2 - point.y * settings.particles.size / 350;
        return point;
      }
      // 创建路径
      ctx.beginPath();
      let t = -Math.PI;
      let point = to(t);
      // ctx.translate(10,10)  //移动心形
      ctx.moveTo(point.x, point.y);
 
      while (t < Math.PI) {
        t += 0.01; // baby steps!
        point = to(t);
        ctx.lineTo(point.x, point.y);
      }
      ctx.closePath();
      // 添加填充
      ctx.fillStyle = '#ea80b0';
      ctx.fill();
      // 创建图像
      let image = new Image();
      image.src = canvas.toDataURL();
      return image;
    })();
 
 
    /*
     * 创建粒子
     */
    let Particle = (function () {
      function Particle() {
        // 创建实例
        this.position = new Point();
        this.velocity = new Point();
        this.acceleration = new Point();
        this.age = 0;
      }
      // 初始化位置 速度 加速度 时间
      Particle.prototype.initialize = function (x, y, dx, dy) {
        this.position.x = x;
        this.position.y = y;
        this.velocity.x = dx;
        this.velocity.y = dy;
        this.acceleration.x = dx * settings.particles.effect;
        this.acceleration.y = dy * settings.particles.effect;
        this.age = 0;
      };
      // 随时间变化
      Particle.prototype.update = function (deltaTime) {
        this.position.x += this.velocity.x * deltaTime;
        this.position.y += this.velocity.y * deltaTime;
        this.velocity.x += this.acceleration.x * deltaTime;
        this.velocity.y += this.acceleration.y * deltaTime;
        this.age += deltaTime;
      };
      // 在canvas上绘制
      Particle.prototype.draw = function (ctx, image) {
        function ease(t) {
          return (--t) * t * t + 1;
        }
        let size = image.width * ease(this.age / settings.particles.duration);
        // 透明度
        ctx.globalAlpha = 1 - this.age / settings.particles.duration;
        // drawImage(img,x,y,width,height) 绘制一个图片以及图片位置大小;
        ctx.drawImage(image, this.position.x - size / 2, this.position.y - size / 2, size, size);
      };
      return Particle;
    })();
 
    /*
     * 创建粒子池
     */
    var ParticlePool = (function () {
      var particles,
        firstActive = 0,
        firstFree = 0,
        duration = settings.particles.duration;
 
      function ParticlePool(length) {
        // 创建并填充粒子池
        particles = new Array(length);
        for (var i = 0; i < particles.length; i++)
          particles[i] = new Particle();
      }
      ParticlePool.prototype.add = function (x, y, dx, dy) {
        particles[firstFree].initialize(x, y, dx, dy);
 
        // 处理循环队列
        firstFree++;
        if (firstFree == particles.length) firstFree = 0;
        if (firstActive == firstFree) firstActive++;
        if (firstActive == particles.length) firstActive = 0;
      };
      ParticlePool.prototype.update = function (deltaTime) {
        var i;
 
        // 更新粒子
        if (firstActive < firstFree) {
          for (i = firstActive; i < firstFree; i++)
            particles[i].update(deltaTime);
        }
        if (firstFree < firstActive) {
          for (i = firstActive; i < particles.length; i++)
            particles[i].update(deltaTime);
          for (i = 0; i < firstFree; i++)
            particles[i].update(deltaTime);
        }
 
        // 删除不活跃粒子
        while (particles[firstActive].age >= duration && firstActive != firstFree) {
          firstActive++;
          if (firstActive == particles.length) firstActive = 0;
        }
 
 
      };
      ParticlePool.prototype.draw = function (ctx, image) {
        // 画出活动的粒子
        if (firstActive < firstFree) {
          for (i = firstActive; i < firstFree; i++)
            particles[i].draw(ctx, image);
        }
        if (firstFree < firstActive) {
          for (i = firstActive; i < particles.length; i++)
            particles[i].draw(ctx, image);
          for (i = 0; i < firstFree; i++)
            particles[i].draw(ctx, image);
        }
      };
      return ParticlePool;
    })();
 
 
 
    let canvas = document.querySelector('canvas')
    let ctx = canvas.getContext('2d')
    let particles = new ParticlePool(settings.particles.length)
    let particleRate = settings.particles.length / settings.particles.duration // particles/sec
    let time
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    (function render() {
      requestAnimationFrame(render);
      let newTime = new Date().getTime() / 1000
      let deltaTime = newTime - (time || newTime)
      time = newTime;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      let particle = new Particle()
      var amount = particleRate * deltaTime;
      for (var i = 0; i < amount; i++) {
        var pos = pointOnHeart(Math.PI - 2 * Math.PI * Math.random());
        var dir = pos.clone().length(settings.particles.velocity);
        particles.add(canvas.width / 2 + pos.x, canvas.height / 2 - pos.y, dir.x, -dir.y);
      }
      
      particles.update(deltaTime);
      particles.draw(ctx, image);
 
    })()      
  </script>
</body>
 
</html>
