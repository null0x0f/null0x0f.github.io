<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NULL&#39;blog</title>
  
  
  <link href="https://null0x0f.github.io/atom.xml" rel="self"/>
  
  <link href="https://null0x0f.github.io/"/>
  <updated>2023-06-18T08:25:54.836Z</updated>
  <id>https://null0x0f.github.io/</id>
  
  <author>
    <name>NULL+</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构</title>
    <link href="https://null0x0f.github.io/posts/79666db.html"/>
    <id>https://null0x0f.github.io/posts/79666db.html</id>
    <published>2023-06-18T08:25:54.836Z</published>
    <updated>2023-06-18T08:25:54.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>树上任意节点的左子树和右子树高度之差不超过1，超过则视为不平衡<br>节点平衡因子 = 左子树高-右子树高</p><p>特性：左子树节点值&lt;根节点值&lt;左子树节点值</p><h3 id="调整最小不平衡子树"><a href="#调整最小不平衡子树" class="headerlink" title="调整最小不平衡子树"></a>调整最小不平衡子树</h3><p>LL 新插入一个节点在左子树的左节点<br>LR<br>RR<br>RL<br>判断方法：从最小的不平衡节点开始操作</p><p>LL：进行右旋，需要将最小的不平衡节点往下三个节点中间的节点作为新的根节点其他两个节点变成左右子树</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h1&gt;&lt;h2 id=&quot;平衡二叉树&quot;&gt;&lt;a href=&quot;#平衡二叉树&quot; class=&quot;headerlink&quot; title=&quot;平衡二叉树&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>jsp_final</title>
    <link href="https://null0x0f.github.io/posts/0.html"/>
    <id>https://null0x0f.github.io/posts/0.html</id>
    <published>2023-06-18T08:25:54.836Z</published>
    <updated>2023-06-18T08:25:54.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jsp-finaltest"><a href="#jsp-finaltest" class="headerlink" title="jsp_finaltest"></a>jsp_finaltest</h1><h2 id="jsp执行过程"><a href="#jsp执行过程" class="headerlink" title="jsp执行过程"></a>jsp执行过程</h2><p>客户端向服务器发送请求。<br>服务器接收到请求，并根据请求的URL和其他参数选择对应的处理程序进行处理。<br>翻译阶段：<br>如果请求的处理程序是JSP文件，服务器会翻译JSP文件成为Servlet源代码。<br>编译阶段：<br>并编译成Java字节码文件。如果请求的处理程序是Servlet或者其他Java类文件，服务器则直接编译Java文件成为字节码文件。<br>执行阶段：<br>服务器根据请求创建一个HTTP响应对象，并将响应头信息写入到这个对象中。<br>如果请求的处理程序需要生成HTML内容，服务器会执行相应的Java代码来生成HTML内容，并将HTML内容写入到HTTP响应对象的正文中。<br>服务器将HTTP响应对象发送回给客户端。<br>客户端接收到HTTP响应，解析响应头和正文，并根据响应头中的Content-Type信息来解析正文内容。如果Content-Type是text/html，客户端会将HTML内容解析并显示在浏览器中。</p><h2 id="三种指令"><a href="#三种指令" class="headerlink" title="三种指令"></a>三种指令</h2><h3 id="page"><a href="#page" class="headerlink" title="page"></a>page</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html import = &quot;java.util.*&quot;; charset=UTF-8&quot;</span><br><span class="line">    pageEncoding=&quot;UTF-8&quot; isErrorPage=&quot;false&quot; %&gt;</span><br></pre></td></tr></table></figure><h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@include file = &quot;***.jsp&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="taglib"><a href="#taglib" class="headerlink" title="taglib"></a>taglib</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib uri=&quot;/WEB-INF/mytaglib.tld&quot; prefix=&quot;mytag&quot; %&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Taglib Example&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Taglib Example&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;The following is a custom tag:&lt;/p&gt;</span><br><span class="line">    &lt;mytag:hello name=&quot;World&quot; /&gt;</span><br><span class="line">    &lt;p&gt;You can view the source code of this page to see how to use custom tags in JSP.&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>我们使用了taglib指令导入了一个名为mytag的自定义标签库。在JSP页面的正文部分，我们使用了<mytag:hello>标签来调用自定义标签库中的hello标签，并传入了一个名为name的参数，值为World。在实际运行时，JSP容器会将<mytag:hello>标签转换为对应的Java代码，然后执行这段代码，最后将执行结果输出到浏览器中.</p><h2 id="jsp声明"><a href="#jsp声明" class="headerlink" title="jsp声明"></a>jsp声明</h2><p><img src="https://img1.imgtp.com/2023/06/18/ZKNbzIJc.png" alt="jsp声明"><br>&lt;%! … %&gt;</p><h2 id="jsp脚本"><a href="#jsp脚本" class="headerlink" title="jsp脚本"></a>jsp脚本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%int a = 10;</span><br><span class="line">int b = 5;</span><br><span class="line">int result = a+b%&gt;//脚本</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="jsp表达式"><a href="#jsp表达式" class="headerlink" title="jsp表达式"></a>jsp表达式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">String name = &quot;World&quot;;</span><br><span class="line">out.print(&quot;Hello, &quot; + name);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h2 id="jsp注释"><a href="#jsp注释" class="headerlink" title="jsp注释"></a>jsp注释</h2><!-- HTML --><p>&lt;%—  JSP —%&gt;</p><p>脚本内: //   /*</p><h2 id="内置对象，流转对象"><a href="#内置对象，流转对象" class="headerlink" title="内置对象，流转对象"></a>内置对象，流转对象</h2><p>流转:request response<br>作用域:pageContext,request,session,application<br>其他:out,config,exception,page</p><p>request对象的原型是javax.servlet.http.HttpServletRequest类<br>response对象的原型是javax.servlet.http.HttpServletResponse类<br>out对象的原型是javax.servlet.jsp.JspWriter类<br>session对象的原型是javax.servlet.http.HttpSession类<br>application对象的原型是javax.servlet.ServletContext类<br>config对象的原型是javax.servlet.ServletConfig类<br>pageContext对象的原型是javax.servlet.jsp.PageContext类<br>page对象的原型是生成的JSP页面类<br>exception对象的原型是java.lang.Throwable类或其子类<br><img src="https://img1.imgtp.com/2023/06/18/a3NKa3DY.png" alt="内置对象.png"></p><h2 id="请求转发重定向"><a href="#请求转发重定向" class="headerlink" title="请求转发重定向"></a>请求转发重定向</h2><h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><h4 id="请求传递："><a href="#请求传递：" class="headerlink" title="请求传递："></a>请求传递：</h4><p>用户向服务器a请求，a将需求传递给b，b直接将结果返回给用户</p><h4 id="请求包含"><a href="#请求包含" class="headerlink" title="请求包含"></a>请求包含</h4><p>用户向服务器a请求，a将需求传递给b，b将结果传递给a，a整合结果，返回给用户</p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>用户向a服务器请求，a返回一个b服务器的地址给用户，用户访问b的服务器，b服务器返回一个信息给用户。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><img src="https://img1.imgtp.com/2023/06/18/Ay8DoZ1L.png" alt="redirect"></p><h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>session<br>code:<br>在这个例子中，如果用户名和密码正确，就将用户名保存在session中，并重定向到欢迎页面（例如welcome.jsp）；否则重定向回登录页面，并附加一个错误参数（例如?error=1）。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class LoginServlet extends HttpServlet &#123;</span><br><span class="line">    public void doPost(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">            throws ServletException, IOException &#123;</span><br><span class="line">        String username = request.getParameter(&quot;username&quot;);</span><br><span class="line">        String password = request.getParameter(&quot;password&quot;);</span><br><span class="line">        if (&quot;admin&quot;.equals(username) &amp;&amp; &quot;123456&quot;.equals(password)) &#123;</span><br><span class="line">            HttpSession session = request.getSession();</span><br><span class="line">            session.setAttribute(&quot;username&quot;, username);</span><br><span class="line">            response.sendRedirect(&quot;welcome.jsp&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            response.sendRedirect(&quot;login.jsp?error=1&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在受保护的资源（例如admin.jsp）中，先检查session中是否包含已登录用户的信息，如果没有则重定向到登录页面：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class AdminServlet extends HttpServlet &#123;</span><br><span class="line">    public void doGet(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">            throws ServletException, IOException &#123;</span><br><span class="line">        HttpSession session = request.getSession(false);</span><br><span class="line">        if (session == null || session.getAttribute(&quot;username&quot;) == null) &#123;</span><br><span class="line">            response.sendRedirect(&quot;login.jsp&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 省略其他处理代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h3><p><img src="https://img1.imgtp.com/2023/06/18/C8dUqihk.png" alt="cookie"></p><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><p> 以下是一些常用的EL表达式：<br>获取请求参数：${param.paramName}，其中paramName是请求参数的名称；<br>获取请求属性：${request.attributeName}，其中attributeName是请求属性的名称；<br>获取session属性：${session.attributeName}，其中attributeName是session属性的名称；<br>获取ServletContext属性：${application.attributeName}，其中attributeName是ServletContext属性的名称；</p><h3 id="EL内置对象"><a href="#EL内置对象" class="headerlink" title="EL内置对象"></a>EL内置对象</h3><p>获取JSP页面作用域（page scope）属性：${pageScope.attributeName}，其中attributeName是页面作用域属性的名称；<br>获取JSP页面上下文（request scope）属性：${requestScope.attributeName}，其中attributeName是页面上下文属性的名称；<br>获取JSP页面会话（session scope）属性：${sessionScope.attributeName}，其中attributeName是页面会话属性的名称；<br>获取JSP页面应用程序（application scope）属性：${applicationScope.attributeName}，其中attributeName是页面应用程序属性的名称；<br>code:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</span><br><span class="line">    pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Hello, EL!&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello, $&#123;param.name&#125;!&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;Your email address is: $&#123;request.email&#125;&lt;/p&gt;</span><br><span class="line">    &lt;c:if test=&quot;$&#123;empty param.name&#125;&quot;&gt;</span><br><span class="line">        &lt;p&gt;Please enter your name.&lt;/p&gt;</span><br><span class="line">    &lt;/c:if&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h3 id="jstl标签"><a href="#jstl标签" class="headerlink" title="jstl标签"></a>jstl标签</h3><h4 id="通用标签"><a href="#通用标签" class="headerlink" title="通用标签"></a>通用标签</h4><p>set,out,remove<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:set var=&quot;example&quot;value = &quot;$&#123;100+1&#125;&quot;scope = &quot;session&quot;/&gt;</span><br><span class="line">&lt;c:out value = &quot;$&#123;example&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure><br>输出101   scope :填内置对象<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:remove var = &quot;example&quot;scope=&quot;session&quot;/&gt;</span><br></pre></td></tr></table></figure><br>删除example变量</p><h4 id="条件标签"><a href="#条件标签" class="headerlink" title="条件标签"></a>条件标签</h4><p>if<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;JSTL If Example&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;c:set var=&quot;score&quot; value=&quot;80&quot;/&gt;</span><br><span class="line">    &lt;c:if test=&quot;$&#123;score &gt;= 60&#125;&quot;&gt;</span><br><span class="line">        &lt;p&gt;Congratulations, you passed the exam!&lt;/p&gt;</span><br><span class="line">    &lt;/c:if&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><br>choose<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;JSTL Choose Example&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;c:set var=&quot;fruit&quot; value=&quot;apple&quot; /&gt;</span><br><span class="line">    &lt;c:choose&gt;</span><br><span class="line">        &lt;c:when test=&quot;$&#123;fruit eq &#x27;apple&#x27;&#125;&quot;&gt;</span><br><span class="line">            &lt;p&gt;It&#x27;s an apple.&lt;/p&gt;</span><br><span class="line">        &lt;/c:when&gt;</span><br><span class="line">        &lt;c:when test=&quot;$&#123;fruit eq &#x27;banana&#x27;&#125;&quot;&gt;</span><br><span class="line">            &lt;p&gt;It&#x27;s a banana.&lt;/p&gt;</span><br><span class="line">        &lt;/c:when&gt;</span><br><span class="line">        &lt;c:otherwise&gt;</span><br><span class="line">            &lt;p&gt;It&#x27;s not an apple or a banana.&lt;/p&gt;</span><br><span class="line">        &lt;/c:otherwise&gt;</span><br><span class="line">    &lt;/c:choose&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h4 id="迭代标签"><a href="#迭代标签" class="headerlink" title="迭代标签"></a>迭代标签</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;JSTL ForEach Example&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;c:set var=&quot;fruits&quot; value=&quot;$&#123;[&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;orange&#x27;]&#125;&quot; /&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;c:forEach items=&quot;$&#123;fruits&#125;&quot; var=&quot;fruit&quot;&gt;</span><br><span class="line">            &lt;li&gt;$&#123;fruit&#125;&lt;/li&gt;</span><br><span class="line">        &lt;/c:forEach&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h2><h3 id="servlet生命周期"><a href="#servlet生命周期" class="headerlink" title="servlet生命周期"></a>servlet生命周期</h3><p>start-&gt;init()-&gt;service()-&gt;destroy()</p><h3 id="servlet注解"><a href="#servlet注解" class="headerlink" title="servlet注解"></a>servlet注解</h3><p>1.@webservlet:用于定义一个Servlet，可以指定Servlet的名称、URL映射等信息<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(name = &quot;MyServlet&quot;, urlPatterns = &quot;/myservlet&quot;)//或者@WebServlet(&quot;/MyServlet&quot;)</span><br><span class="line">public class MyServlet extends HttpServlet &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>2.@WebInitParam：用于为Servlet指定初始化参数，可以在Servlet代码中通过getInitParameter()方法获取这些参数的值。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(name = &quot;MyServlet&quot;, urlPatterns = &quot;/myservlet&quot;, initParams = &#123;</span><br><span class="line">        @WebInitParam(name = &quot;username&quot;, value = &quot;admin&quot;),</span><br><span class="line">        @WebInitParam(name = &quot;password&quot;, value = &quot;123456&quot;)&#125;)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">public class MyServlet extends HttpServlet &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>3.@WebFilter：用于定义一个过滤器，可以指定过滤器的名称、URL映射等信息。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@WebFilter(filterName = &quot;MyFilter&quot;, urlPatterns = &quot;/*&quot;)</span><br><span class="line">public class MyFilter implements Filter &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>4.@WebListener：用于定义一个监听器，可以指定监听的事件类型等信息。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@WebListener</span><br><span class="line">public class MyContextListener implements ServletContextListener &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(&quot;/login&quot;)</span><br><span class="line">public class LoginServlet extends HttpServlet &#123;</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line">    </span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        String username = request.getParameter(&quot;username&quot;);</span><br><span class="line">        String password = request.getParameter(&quot;password&quot;);</span><br><span class="line">        </span><br><span class="line">        if (&quot;admin&quot;.equals(username) &amp;&amp; &quot;123456&quot;.equals(password)) &#123;</span><br><span class="line">            request.getRequestDispatcher(&quot;welcome.jsp&quot;).forward(request, response);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            request.setAttribute(&quot;errorMsg&quot;, &quot;Invalid username or password!&quot;);</span><br><span class="line">            request.getRequestDispatcher(&quot;index.jsp&quot;).forward(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java-Bean"><a href="#java-Bean" class="headerlink" title="java Bean"></a>java Bean</h2><p>Java Bean的基本原则包括以下几点：</p><p>1.实现Serializable接口(共有类)：Java Bean类必须实现Serializable接口，以便能够在网络上传输或者在不同的Java应用程序之间进行传递。</p><p>2.封装属性：Java Bean类应该将属性封装起来，通过公共的getter和setter方法来访问和修改属性值。</p><p>3.提供无参构造器：Java Bean类必须提供一个无参构造器，以便能够通过反射创建实例。</p><p>4.实现序列化<br>常见的三种Java Bean包括：</p><p>实体Bean：用于封装数据的Java Bean，通常包含一些属性和对应的getter和setter方法，以及一些辅助方法。entity类</p><p>业务Bean：用于提供一些服务的Java Bean，例如计算、数据转换等，通常包含一些公共方法。<br>业务类，service类<br>持久化Bean：数据库访问类，dao类</p><h2 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h2><p>mvc:model,view,controller<br>主要目的是将应用程序的业务逻辑和用户界面分离，以便更好地管理和维护代码。</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p><img src="https://img1.imgtp.com/2023/06/18/RwUcdItS.png" alt="benefit"></p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>model:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String gender;</span><br><span class="line"></span><br><span class="line">    public Student(int id, String name, int age, String gender) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getGender() &#123;</span><br><span class="line">        return gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setGender(String gender) &#123;</span><br><span class="line">        this.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="view"><a href="#view" class="headerlink" title="view"></a>view</h4><p>add.jsp<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Add Student&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Add Student&lt;/h1&gt;</span><br><span class="line">    &lt;form action=&quot;addStudent&quot; method=&quot;post&quot;&gt;</span><br><span class="line">        &lt;label for=&quot;name&quot;&gt;Name:&lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot; required&gt;&lt;br&gt;</span><br><span class="line">        &lt;label for=&quot;age&quot;&gt;Age:&lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;number&quot; id=&quot;age&quot; name=&quot;age&quot; min=&quot;0&quot; required&gt;&lt;br&gt;</span><br><span class="line">        &lt;label for=&quot;gender&quot;&gt;Gender:&lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;radio&quot; id=&quot;male&quot; name=&quot;gender&quot; value=&quot;Male&quot; required&gt;</span><br><span class="line">        &lt;label for=&quot;male&quot;&gt;Male&lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;radio&quot; id=&quot;female&quot; name=&quot;gender&quot; value=&quot;Female&quot; required&gt;</span><br><span class="line">        &lt;label for=&quot;female&quot;&gt;Female&lt;/label&gt;&lt;br&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;Add&quot;&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>showlist.jsp<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Student List&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Student List&lt;/h1&gt;</span><br><span class="line">    &lt;table border=&quot;1&quot;&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;th&gt;ID&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;Name&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;Age&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;Gender&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;Actions&lt;/th&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;% for (Student student : studentList) &#123; %&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;&lt;%= student.getId() %&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;%= student.getName() %&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;%= student.getAge() %&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;%= student.getGender() %&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                &lt;a href=&quot;deleteStudent?id=&lt;%= student.getId() %&gt;&quot;&gt;Delete&lt;/a&gt;</span><br><span class="line">                &lt;a href=&quot;modifyStudent?id=&lt;%= student.getId() %&gt;&quot;&gt;Modify&lt;/a&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;% &#125; %&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;a href=&quot;add.jsp&quot;&gt;Add Student&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><br>modify.jsp<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Modify Student&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Modify Student&lt;/h1&gt;</span><br><span class="line">    &lt;form action=&quot;modifyStudent&quot; method=&quot;post&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;&lt;%= student.getId() %&gt;&quot;&gt;</span><br><span class="line">        &lt;label for=&quot;name&quot;&gt;Name:&lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot; value=&quot;&lt;%= student.getName() %&gt;&quot; required&gt;&lt;br&gt;</span><br><span class="line">        &lt;label for=&quot;age&quot;&gt;Age:&lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;number&quot; id=&quot;age&quot; name=&quot;age&quot; value=&quot;&lt;%= student.getAge() %&gt;&quot; min=&quot;0&quot; required&gt;&lt;br&gt;</span><br><span class="line">        &lt;label for=&quot;gender&quot;&gt;Gender:&lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;radio&quot; id=&quot;male&quot; name=&quot;gender&quot; value=&quot;Male&quot; &lt;% if (&quot;Male&quot;.equals(student.getGender())) &#123; %&gt;checked&lt;% &#125; %&gt; required&gt;</span><br><span class="line">        &lt;label for=&quot;male&quot;&gt;Male&lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;radio&quot; id=&quot;female&quot; name=&quot;gender&quot; value=&quot;Female&quot; &lt;% if (&quot;Female&quot;.equals(student.getGender())) &#123; %&gt;checked&lt;% &#125; %&gt; required&gt;</span><br><span class="line">        &lt;label for=&quot;female&quot;&gt;Female&lt;/label&gt;&lt;br&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;Save&quot;&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h4 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h4><p>AddStudentServlet.java：添加学生的Servlet<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class AddStudentServlet extends HttpServlet &#123;</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        // 获取用户提交的表单数据</span><br><span class="line">        String name = request.getParameter(&quot;name&quot;);</span><br><span class="line">        int age = Integer.parseInt(request.getParameter(&quot;age&quot;));</span><br><span class="line">        String gender = request.getParameter(&quot;gender&quot;);</span><br><span class="line"></span><br><span class="line">        // 创建Student对象，并将其保存到数据库中</span><br><span class="line">        Student student = new Student(name, age, gender);</span><br><span class="line">        StudentDao studentDao = new StudentDaoImpl();</span><br><span class="line">        studentDao.addStudent(student);</span><br><span class="line"></span><br><span class="line">        // 重定向到学生列表页面</span><br><span class="line">        response.sendRedirect(&quot;showList&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>ShowListServlet.java<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ShowListServlet extends HttpServlet &#123;</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        // 查询数据库中所有的学生信息，并将其保存到request对象中</span><br><span class="line">        StudentDao studentDao = new StudentDaoImpl();</span><br><span class="line">        List&lt;Student&gt; studentList = studentDao.getAllStudents();</span><br><span class="line">        request.setAttribute(&quot;studentList&quot;, studentList);</span><br><span class="line"></span><br><span class="line">        // 转发到学生列表页面</span><br><span class="line">        request.getRequestDispatcher(&quot;showList.jsp&quot;).forward(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>DeleteStudentServlet.java<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class DeleteStudentServlet extends HttpServlet &#123;</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        // 获取要删除的学生的ID，并将其从数据库中删除</span><br><span class="line">        int id = Integer.parseInt(request.getParameter(&quot;id&quot;));</span><br><span class="line">        StudentDao studentDao = new StudentDaoImpl();</span><br><span class="line">        studentDao.deleteStudent(id);</span><br><span class="line"></span><br><span class="line">        // 重定向到学生列表页面</span><br><span class="line">        response.sendRedirect(&quot;showList&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>ModifyStudentServlet.java<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class ModifyStudentServlet extends HttpServlet &#123;</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        // 获取要修改的学生的ID，并将其从数据库中查询出来</span><br><span class="line">        int id = Integer.parseInt(request.getParameter(&quot;id&quot;));</span><br><span class="line">        StudentDao studentDao = new StudentDaoImpl();</span><br><span class="line">        Student student = studentDao.getStudentById(id);</span><br><span class="line"></span><br><span class="line">        // 将查询出来的学生信息保存到request对象中</span><br><span class="line">        request.setAttribute(&quot;student&quot;, student);</span><br><span class="line"></span><br><span class="line">        // 转发到修改学生信息页面</span><br><span class="line">        request.getRequestDispatcher(&quot;modify.jsp&quot;).forward(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        // 获取用户提交的表单数据</span><br><span class="line">        int id = Integer.parseInt(request.getParameter(&quot;id&quot;));</span><br><span class="line">        String name = request.getParameter(&quot;name&quot;);</span><br><span class="line">        int age = Integer.parseInt(request.getParameter(&quot;age&quot;));</span><br><span class="line">        String gender = request.getParameter(&quot;gender&quot;);</span><br><span class="line"></span><br><span class="line">        // 创建Student对象，并更新其在数据库中的信息</span><br><span class="line">        Student student = new Student(id, name, age, gender);</span><br><span class="line">        StudentDao studentDao = new StudentDaoImpl();</span><br><span class="line">        studentDao.updateStudent(student);</span><br><span class="line"></span><br><span class="line">        // 重定向到学生列表页面</span><br><span class="line">        response.sendRedirect(&quot;showList&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;jsp-finaltest&quot;&gt;&lt;a href=&quot;#jsp-finaltest&quot; class=&quot;headerlink&quot; title=&quot;jsp_finaltest&quot;&gt;&lt;/a&gt;jsp_finaltest&lt;/h1&gt;&lt;h2 id=&quot;jsp执行过程&quot;&gt;&lt;a href=&quot;#js</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>c plus plus</title>
    <link href="https://null0x0f.github.io/posts/d99aa42e.html"/>
    <id>https://null0x0f.github.io/posts/d99aa42e.html</id>
    <published>2023-04-24T11:22:45.000Z</published>
    <updated>2023-06-18T08:25:54.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cpp知识补充"><a href="#cpp知识补充" class="headerlink" title="cpp知识补充"></a>cpp知识补充</h1><p>01 - 侯捷 - C++面向对象高级开发（上下两部曲）</p><p>02 - 侯捷 - STL标准库和泛型编程</p><p>03 - 侯捷 - C++设计模式</p><p>04 - 侯捷 - C++新标准C++11&amp;14</p><p>05 - 侯捷 - C++内存管理机制</p><p>06 - 侯捷 C++ Startup 揭密：C++ 程序的生前和死后</p><p>07、算法原理与实践（选修）</p><p>08、系统设计与实践（选修）</p><p>书籍:c++ primer<br>   effective modern c++<br>   stl源码剖析</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>拿来当c++知识点补充库，顺序不是按照学习的顺序，是感觉哪个不会了，看书或视频补充知识点。</p><h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><p>定义命名空间<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//如果不引入 using namespace std;就需要我们显示引入,例如std::cout</span><br><span class="line">namespace a</span><br><span class="line">&#123;</span><br><span class="line">  int a = 10;</span><br><span class="line">&#125;</span><br><span class="line">namespace b</span><br><span class="line">&#123;</span><br><span class="line">int a = 20;</span><br><span class="line">namespace c</span><br><span class="line">&#123;</span><br><span class="line">  int a = 30;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>使用命名空间<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  using namespace a;</span><br><span class="line">using namespace b;</span><br><span class="line">cout &lt;&lt; a::a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; b::a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; b::c::a &lt;&lt; endl;</span><br><span class="line">using b::c::a;</span><br><span class="line">cout &lt;&lt; a;</span><br><span class="line">  </span><br><span class="line">  system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不使用using namespace std 原因：<br>如果没有命名空间，这些变量、函数、类的名称将都存在于全局命名空间中，当定义了一个函数名与标准库中函数名相同时，就会发生冲突。<br>比如，我们在自己的程序中定义了一个Stack类，而我们程序中使用的某个库中也可能定义了一个同名的类，此时名称就冲突了。</p><h2 id="顶层const和底层const"><a href="#顶层const和底层const" class="headerlink" title="顶层const和底层const"></a>顶层const和底层const</h2><p>const修饰的变量不可以改变就是顶层const：<br>const int a = 10;<br>底层const：<br>const int &amp;ra = 10;</p><p>c++ primer :当执行对象的拷贝操作时，常量的顶层const不受什么影响，而底层const必须一致</p><p> const引用理解:<br> 1.引用不是对象且不进行拷贝<br> 2.常量引用如果在左侧，右侧可以接任何东西<br> 3.非常量引用 = 常量  error<br> 4.引用如果在等号右侧请忽略引用<br> 5.非常量 = 常引用</p><p>判断方法:<br><img src="/source/img/const1.png" alt="const1"><br><img src="/source/img/const2.png" alt="const2"></p><p>代码详解:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">int i = 0;</span><br><span class="line">const int p = 10;//顶层const(不能被修改)</span><br><span class="line">const int* p1 = &amp;p;</span><br><span class="line">p1 = &amp;i;</span><br><span class="line">//底层const 允许修改p1的值   const 修饰的是int 不能改变的是 *p1  int *p1是个指针，地址没变，里面值改变无所谓   const修饰的是什么,p1就指向的是什么 *p就相当于（const int）*p</span><br><span class="line">    int* const p2 =&amp;i;//顶层const p2的值不允许被修改 p2是个指针，里面存放的是地址，地址是不可以改变的，值是可以改变的。  const  int*p2  然后你可以通过改变p2指向这个内存地址里的值,来改变p2读出来的值</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>const int* p1 = &p;</p><p>p1是一个指向const int类型的指针变量。<br>&amp;p是一个指向int类型变量p的地址。<br>通过将&amp;p赋值给p1，p1成为了一个指向p的const int类型的指针。<br>这意味着p1指向的int类型的数据是只读的，不能通过p1来修改。<br>int* const p2 = &i;</p><p>p2是一个指向int类型的常量指针变量。<br>&amp;i是一个指向int类型变量i的地址。<br>通过将&amp;i赋值给p2，p2成为了一个指向i的int类型的常量指针。<br>这意味着p2指向的int类型数据可以修改，但是p2本身的指向是不可变的，即p2不能指向其他的地址。</p><h2 id="register-加强"><a href="#register-加强" class="headerlink" title="register 加强"></a>register 加强</h2><p>register 关键字请求编译器将局部变量存储于寄存器中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">  std::cout&lt;&lt;&amp;a&lt;&lt;endl;</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="引用剖析"><a href="#引用剖析" class="headerlink" title="引用剖析"></a>引用剖析</h2><h3 id="引用语法"><a href="#引用语法" class="headerlink" title="引用语法"></a>引用语法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">   <span class="type">int</span> &amp;b = a;<span class="comment">//b就是a的别名 int *const b = &amp;a</span></span><br><span class="line">   b= <span class="number">11</span>;<span class="comment">//*b = 11</span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用本质"><a href="#引用本质" class="headerlink" title="引用本质"></a>引用本质</h3><p>引用在c++内部实现是一个常量指针<br>Type&amp; name&lt;——&gt;Type * const name</p><h3 id="函数返回值是引用"><a href="#函数返回值是引用" class="headerlink" title="函数返回值是引用"></a>函数返回值是引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> *<span class="title">get_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回的是本身的一个副本(20)</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">get_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="type">int</span> a2 = <span class="built_in">get_2</span>();<span class="comment">//20</span></span><br><span class="line">   <span class="type">int</span> &amp;a3 = <span class="built_in">get_2</span>();<span class="comment">//返回的是a的本身 地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若返回静态变量或全局变量<br>可以成为其他引用初始值<br>既可以作为右值使用，也可以作为左值使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">g1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">g2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">  a++;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">g1</span>() =<span class="number">100</span>;<span class="comment">//error </span></span><br><span class="line">   <span class="built_in">g2</span>() = <span class="number">100</span>;<span class="comment">//返回的是变量本身 g2()返回的a当左值使用 </span></span><br><span class="line">   <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h2><p> 用来代替宏代码片段<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> inline void fun() </span><br><span class="line">&#123;</span><br><span class="line">   int a = 10;</span><br><span class="line">   cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> #define Myfunc(a,b)((a)&lt;(b)？(a):(b))</span><br><span class="line"> inline int myfunc(int a,int b) </span><br><span class="line">&#123;</span><br><span class="line">   return a&lt;b?a:b</span><br><span class="line">&#125;</span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line"> int c1 = myfunc(++a,b)//a=2 b = 3 c =2</span><br><span class="line"> int c2 = Myfunc(++a,b)//==&gt;宏展开((++a)&lt;(b)?(++a):(b))</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 内联不能做声明，必须和函数体实现写在一块<br>adsd</p><h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p> 构造函数：完成对属性的初始化工作（先创建的对象先构造）<br> 析构函数：先创建的对象后释放（栈机制）</p><h3 id="构造函数分类"><a href="#构造函数分类" class="headerlink" title="构造函数分类"></a>构造函数分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class test</span><br><span class="line">&#123;</span><br><span class="line">  private:</span><br><span class="line">  int a,b,c,d;</span><br><span class="line">  public:</span><br><span class="line">  test()//无参构造</span><br><span class="line">  &#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  test(int a,int b)//有参构造</span><br><span class="line">  &#123;</span><br><span class="line">     this-&gt;a = a;</span><br><span class="line">     this-&gt;b = b;</span><br><span class="line">  &#125;</span><br><span class="line">  test(const test&amp; obj)//赋值构造函数</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">   test t2//无参构造</span><br><span class="line">   test t(2,4);//有参调用</span><br><span class="line">   test t1(t);//拷贝构造</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深拷贝和浅拷贝问题"><a href="#深拷贝和浅拷贝问题" class="headerlink" title="深拷贝和浅拷贝问题"></a>深拷贝和浅拷贝问题</h3><h4 id="浅拷贝分析"><a href="#浅拷贝分析" class="headerlink" title="浅拷贝分析"></a>浅拷贝分析</h4><p>默认的拷贝构造函数，编译器提供<br>把对象1的属性拷贝给对象二<br>把指针变量的值拷贝给对象二，并没有把指针变量所指向的内存空间的数据拷贝过来<br>两个指针变量指向同一个空间</p><p>obj2析构函数 把指向的内存空间析构<br>obj2 指向null，obj1仍然指向堆里被释放的内存空间。<br>obj1再析构，还是析构的obj2之前析构的那一块空间，，结果析构两次，造成空间的coredump</p><p>coredump出现原因:<br><img src="/source/img/coredump.png" alt="coredump"></p><h4 id="等号操作也是浅拷贝操作"><a href="#等号操作也是浅拷贝操作" class="headerlink" title="等号操作也是浅拷贝操作"></a>等号操作也是浅拷贝操作</h4><h2 id="临时对象"><a href="#临时对象" class="headerlink" title="临时对象"></a>临时对象</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>构造之后马上析构</p><h3 id="构造函数中调用构造函数"><a href="#构造函数中调用构造函数" class="headerlink" title="构造函数中调用构造函数"></a>构造函数中调用构造函数</h3><p>危险行为</p><h2 id="new-和delete"><a href="#new-和delete" class="headerlink" title="new 和delete"></a>new 和delete</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int *arr = new int[10];</span><br><span class="line">delete []arr;</span><br><span class="line"></span><br><span class="line">//动态分配对象</span><br><span class="line">object *pt = new object;</span><br><span class="line">delete pt;</span><br></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="友元函数和友元类"><a href="#友元函数和友元类" class="headerlink" title="友元函数和友元类"></a>友元函数和友元类</h3><h4 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">friend void modify(A* pa,int _a);</span><br><span class="line">A(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;a = a;</span><br><span class="line">this-&gt;b = b;</span><br><span class="line">&#125;</span><br><span class="line">void geta()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;this-&gt;a;</span><br><span class="line">&#125;</span><br><span class="line">//声明位置和public和private没关系</span><br><span class="line">private:</span><br><span class="line">int a;</span><br><span class="line">int b;</span><br><span class="line">&#125;;</span><br><span class="line">void modify(A* pa,int _a)</span><br><span class="line">&#123;</span><br><span class="line">pa-&gt;a = _a;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">A a(5, 3);</span><br><span class="line">modify(&amp;a, 100);</span><br><span class="line">a.geta();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h4><h4 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h4><p>这两个都写在vs里了<br><img src="/source/img/%E9%87%8D%E8%BD%BD.png" alt="重载"></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h3 id="访问父类的语法和概念"><a href="#访问父类的语法和概念" class="headerlink" title="访问父类的语法和概念"></a>访问父类的语法和概念</h3><h3 id="派生类的访问控制"><a href="#派生类的访问控制" class="headerlink" title="派生类的访问控制"></a>派生类的访问控制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">类的单个类访问控制</span><br><span class="line">//public 修饰地成员变量方法在类的内部 类的外部都能使用</span><br><span class="line">//protected 修饰的成员变量方法，在类的内部使用，在继承的子类中可用</span><br><span class="line">//private 修饰地成员变量方法只能在类的内部使用 类的外部不行</span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">  int a;</span><br><span class="line">  void printT()</span><br><span class="line">  &#123;</span><br><span class="line">  cout&lt;&lt;&quot;printT&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  protected:</span><br><span class="line">  int b;</span><br><span class="line">  private:</span><br><span class="line">  int c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class test:public Test</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">   void user()</span><br><span class="line">   &#123;</span><br><span class="line">     a = 0;//ok</span><br><span class="line">     b= 0;//ok </span><br><span class="line">     c = 0;//error 私有变量</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/source/img/%E6%B4%BE%E7%94%9F%E7%B1%BB%E8%AE%BF%E9%97%AE.png" alt="派生类访问"><br>protect 关键字修饰变量使用，是为了继承</p><h3 id="继承中构造和析构"><a href="#继承中构造和析构" class="headerlink" title="继承中构造和析构"></a>继承中构造和析构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//赋值兼容性原则</span><br><span class="line">//1.基类指针(引用)指向子类对象 可以调用父类方法</span><br><span class="line">class Parent</span><br><span class="line">&#123;</span><br><span class="line">  private:</span><br><span class="line">  int a;</span><br><span class="line">  int b;</span><br><span class="line">  public:</span><br><span class="line">  Parent(int a1,int b1):a(a1),b(b1)&#123;&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">class child</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">int c;</span><br><span class="line">public:</span><br><span class="line">child(int a,int b,int c1):parent(a,b),c(c1)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/source/img/%E7%BB%A7%E6%89%BF1.png" alt="继承1"><br><img src="/source/img/%E7%BB%A7%E6%89%BF2.png" alt="继承2"></p><h3 id="继承和虚函数"><a href="#继承和虚函数" class="headerlink" title="继承和虚函数"></a>继承和虚函数</h3><p>virtual函数:你希望derived class 重新定义它，且你对他已有默认定义<br>pure virtual 函数:erived class 重新定义它，且你对他没有默认定义</p><h3 id="复合和继承"><a href="#复合和继承" class="headerlink" title="复合和继承"></a>复合和继承</h3><h3 id="委托和继承"><a href="#委托和继承" class="headerlink" title="委托和继承"></a>委托和继承<img src="delegation.png" alt="delegation"></h3><p><img src="/source/img/%E5%A7%94%E6%89%982.png" alt="委托2"></p><h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class person//抽象基类(类似于接口)</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">string name;</span><br><span class="line">int height;</span><br><span class="line">int age;</span><br><span class="line">public:</span><br><span class="line">virtual void getinfo() const = 0;//纯虚函数</span><br><span class="line">virtual void action() = 0;</span><br><span class="line">string getname()</span><br><span class="line">&#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">person(string&amp; s, int h,int a) :name(s), height(h),age(a) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class dancer :public person</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">string danceaction;</span><br><span class="line">public:</span><br><span class="line">dancer(string na,int h, int a, string ac) :person(na,h,a)</span><br><span class="line">&#123;</span><br><span class="line">danceaction = ac;</span><br><span class="line">&#125;</span><br><span class="line">void getinfo() const</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;name:&quot; &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;height:&quot; &lt;&lt; height &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;age:&quot; &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;danceaction:&quot; &lt;&lt;danceaction&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void action()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;dance&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。<br>因此，如果一个 ABC 的子类需要被实例化，则必须实现每个纯虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。<br>可用于实例化对象的类被称为具体类。<a href="https://www.runoob.com/cplusplus/cpp-interfaces.html">https://www.runoob.com/cplusplus/cpp-interfaces.html</a></p><h3 id="继承的动态内存分配"><a href="#继承的动态内存分配" class="headerlink" title="继承的动态内存分配"></a>继承的动态内存分配</h3><p>基类使用动态内存分配，派生类不使用动态内存分配。<br>可以省略构造函数和析构函数中的内存分配和释放操作，直接继承基类中的构造和析构函数。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">    Base(const char* str) &#123;</span><br><span class="line">        data_ = new char[strlen(str) + 1];</span><br><span class="line">        strcpy(data_, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual ~Base() &#123;</span><br><span class="line">        delete[] data_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const char* getData() const &#123;</span><br><span class="line">        return data_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    char* data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 派生类，不使用动态内存分配</span><br><span class="line">class Derived : public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    Derived(const char* str, int value)</span><br><span class="line">        : Base(str), value_(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    int getValue() const &#123;</span><br><span class="line">        return value_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int value_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>基类使用动态内存分配，派生类也使用动态内存分配<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class BASE</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">char* base;</span><br><span class="line">public:</span><br><span class="line">BASE(const char *str)</span><br><span class="line">&#123;</span><br><span class="line">base = new char[strlen(str) + 1];</span><br><span class="line">strcpy(base, str);</span><br><span class="line">&#125;</span><br><span class="line">virtual ~BASE()</span><br><span class="line">&#123;</span><br><span class="line">delete[]base;</span><br><span class="line">&#125;</span><br><span class="line">BASE&amp; operator=(const BASE&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">if (this == &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line">delete[]base;</span><br><span class="line">base = new char[strlen(str.base) + 1];</span><br><span class="line">strcpy(base,str.base);</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class derived :public BASE</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">char* dervived;</span><br><span class="line">public:</span><br><span class="line">derived(const char* str):BASE(str)</span><br><span class="line">&#123;</span><br><span class="line">dervived = new char[strlen(str) + 1];</span><br><span class="line">strcpy(dervived, str);</span><br><span class="line">&#125;</span><br><span class="line">derived&amp; operator=(const derived&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">if (this == &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line">delete[]dervived;</span><br><span class="line">BASE::operator=(str);</span><br><span class="line">dervived = new char[strlen(str.dervived) + 1];</span><br><span class="line">strcpy(dervived, str.dervived);</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line">~derived()</span><br><span class="line">&#123;</span><br><span class="line">delete[] dervived;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="conversion-function"><a href="#conversion-function" class="headerlink" title="conversion function"></a>conversion function</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">fraction</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> numrator;</span><br><span class="line"><span class="type">int</span> denominator;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">fraction</span>(<span class="type">int</span> num, <span class="type">int</span> den = <span class="number">1</span>) :<span class="built_in">numrator</span>(num), <span class="built_in">denominator</span>(den) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">double</span>(numrator * <span class="number">1.0</span> / denominator);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> d = f + <span class="number">4</span>;</span><br><span class="line">cout &lt;&lt; d;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>double d = 4 + f;这一语句会首先查找Fraction是否有重载操作符 operator + (double, Fraction) 的函数，由于没有，所以调用会转换函数operator double() const。</p><p>另外，转换函数除了可以将一个类型转换成另一个基本类型，还可以将一个类型转换成另一个复合类型（例如string类型）。</p><h4 id="non-explicit-one-argument-ctor"><a href="#non-explicit-one-argument-ctor" class="headerlink" title="non -explicit-one-argument ctor"></a>non -explicit-one-argument ctor</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Fraction </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Fraction(int num, int den=1) :</span><br><span class="line">        m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Fraction operator + (const Fraction&amp; f) &#123;</span><br><span class="line">        return Fraction(...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int m_numerator;  // 分子</span><br><span class="line">    int m_denominator;  // 分母</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Fraction f(3, 5);</span><br><span class="line">Fraction d2 = f + 4; </span><br></pre></td></tr></table></figure><p>只要一个实参就够了，也可以传两个实参。将别的东西转换成这个类对象</p><h4 id="conversion-function-vs-non-explicit-one-argument-constructor"><a href="#conversion-function-vs-non-explicit-one-argument-constructor" class="headerlink" title="conversion function vs. non-explicit-one-argument constructor"></a>conversion function vs. non-explicit-one-argument constructor</h4><h4 id="explicit-one-argument-constructor"><a href="#explicit-one-argument-constructor" class="headerlink" title="explicit-one-argument constructor"></a>explicit-one-argument constructor</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Fraction </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    explicit Fraction(int num, int den=1) :</span><br><span class="line">        m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    operator double() const &#123;</span><br><span class="line">        return (double) (m_numerator / m_denominator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Fraction operator + (const Fraction&amp; f) &#123;</span><br><span class="line">        return Fraction(...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int m_numerator;  // 分子</span><br><span class="line">    int m_denominator;  // 分母</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Fraction f(3, 5);</span><br><span class="line">Fraction d2 = f + 4;  // [Error] convertion from double to Fraction requested</span><br></pre></td></tr></table></figure><p>由于在构造函数前面增加了explicit关键字，所以不能将4转换成Fraction类型；也不能先将f转换成double类型，与4相加后再将double转换成Fraction。</p><h2 id="pointer-like-classes"><a href="#pointer-like-classes" class="headerlink" title="pointer like classes"></a>pointer like classes</h2><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>智能指针是你在堆栈上声明的类模板，并可通过使用指向某个堆分配的对象的原始指针进行初始化。 在初始化智能指针后，它将拥有原始的指针。 这意味着智能指针负责删除原始指针指定的内存。 智能指针析构函数包括要删除的调用，并且由于在堆栈上声明了智能指针，当智能指针超出范围时将调用其析构函数，尽管堆栈上的某处将进一步引发异常。</p><p>C++ 中有三种常用的智能指针：</p><ol><li><p>unique_ptr：独占所有权的智能指针，不能被复制，只能被移动。当 unique_ptr 超出作用域时，它所指向的对象会被自动释放。</p></li><li><p>shared_ptr：共享所有权的智能指针，可以被多个 shared_ptr 共享。当最后一个 shared_ptr 超出作用域时，它所指向的对象会被自动释放。</p></li><li><p>weak_ptr：弱引用的智能指针，不能直接访问所指向的对象，必须通过 lock() 函数获得一个 shared_ptr 才能访问。weak_ptr 不会增加所指对象的引用计数，因此不会影响所指对象的生命周期。</p></li></ol><h4 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h4><p>用法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;memory&gt;</span><br><span class="line">shared_ptr&lt;double&gt; p1(new double(42));</span><br><span class="line">shared_ptr&lt;int&gt;p2= make_shared&lt;int&gt;(42);</span><br></pre></td></tr></table></figure><br>拷贝和赋值<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">auto r = make_shared&lt;int&gt;(42);//r指向int只有一个引用</span><br><span class="line">r=q;//给r赋值</span><br><span class="line">    //q指向的对象引用次数++</span><br><span class="line">    //r指向对象引用次数--</span><br><span class="line">    //r没有引用了，就会自动释放</span><br></pre></td></tr></table></figure><br>离开作用域，它指向内存也会自动释放<br>但是如果有其他智能指针也指向这块内存，他就不会被释放<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void use_factory(T arg)</span><br><span class="line">&#123;</span><br><span class="line">   shared_ptr&lt;Foo&gt; p = factory(arg);</span><br><span class="line">   return p;//引用计数增加</span><br><span class="line">&#125;//离开作用域但不会被释放</span><br></pre></td></tr></table></figure></p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><h2 id="fuction-like-classes"><a href="#fuction-like-classes" class="headerlink" title="fuction like classes"></a>fuction like classes</h2><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><h3 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h3><p><img src="/source/img/%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF.png" alt="成员模板.png"></p><h3 id="模板特化"><a href="#模板特化" class="headerlink" title="模板特化"></a>模板特化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">template&lt;&gt;</span><br><span class="line">struct hash&lt;char&gt;</span><br><span class="line">&#123;</span><br><span class="line"> size_t operator()(char x) const</span><br><span class="line">&#123;</span><br><span class="line">   return x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;&gt;</span><br><span class="line">struct hash&lt;int&gt;</span><br><span class="line">&#123;</span><br><span class="line"> size_t operator()(int x) const</span><br><span class="line">&#123;</span><br><span class="line">   return x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;&gt;</span><br><span class="line">struct hash&lt;long&gt;</span><br><span class="line">&#123;</span><br><span class="line"> size_t operator()(long x) const</span><br><span class="line">&#123;</span><br><span class="line">   return x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="偏特化-局部特化"><a href="#偏特化-局部特化" class="headerlink" title="偏特化(局部特化)"></a>偏特化(局部特化)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T,class alloc&gt;</span><br><span class="line"> class name</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class alloc&gt;</span><br><span class="line">class name&lt;bool, alloc&gt; </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>范围的偏<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">c</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">c</span>&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>如果使用者使用的是指针就用第二个模板<br>如果不是指针，用的是第一个模板</p><h3 id="模板模板参数"><a href="#模板模板参数" class="headerlink" title="模板模板参数"></a>模板模板参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T,template&lt;class T&gt; class smartptr&gt;</span><br><span class="line"></span><br><span class="line">//第一个参数是 T类型 ，第二个参数是一个smartptr，它可以指定一个T类型变量</span><br><span class="line">class XCls</span><br><span class="line">&#123;</span><br><span class="line"> private:</span><br><span class="line"> smartptr&lt;T&gt; sp;</span><br><span class="line"> public:</span><br><span class="line"> XCls():sp(new T)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">XCls&lt;string,shared_ptr&gt; p1;</span><br></pre></td></tr></table></figure><h2 id="三个主题"><a href="#三个主题" class="headerlink" title="三个主题"></a>三个主题</h2><h3 id="pack"><a href="#pack" class="headerlink" title="pack"></a>pack</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T,typename...Types&gt;</span><br><span class="line">void print(const T&amp;firstArg,const Type&amp;...args)</span><br><span class="line">&#123;</span><br><span class="line">   cout&lt;&lt;firstArg&lt;&lt;endl;</span><br><span class="line">   print(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用sizeof…(args)可以知道包有多少</p><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>auto声明变量必须要赋值</p><h3 id="ranged-base-for"><a href="#ranged-base-for" class="headerlink" title="ranged-base for"></a>ranged-base for</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;double&gt; vec;</span><br><span class="line">for(auto elem:vec)</span><br><span class="line">&#123;</span><br><span class="line">  cout&lt;&lt;elem&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(auto&amp; elem:vec)</span><br><span class="line">&#123;</span><br><span class="line">  elem*=3;</span><br><span class="line">&#125;//改变原来vec里的值</span><br></pre></td></tr></table></figure><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int x = 0;</span><br><span class="line">int* p = &amp;x;</span><br><span class="line">int&amp; r =x;//r代表x,r不能代表其他的了</span><br><span class="line">int x2 = 5;</span><br><span class="line">r = x2;//r不能代表x，现在r,x都是5</span><br><span class="line">int&amp; r2 =r;</span><br></pre></td></tr></table></figure><p>reference一定要有初值，只能代表一个，不能代表其他</p><p>32位电脑指针占四个字节</p><p>参数传递</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h2 id="重载new-delete"><a href="#重载new-delete" class="headerlink" title="重载new(),delete()"></a>重载new(),delete()</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line"> void* operator new(std::size_t size)</span><br><span class="line"> &#123;</span><br><span class="line">  std::cout &lt;&lt; &quot;operator new&quot; &lt;&lt; std::endl;</span><br><span class="line">  return std::malloc(size);</span><br><span class="line"> &#125;</span><br><span class="line"> void operator delete(void* ptr)</span><br><span class="line">&#123;</span><br><span class="line"> std::cout &lt;&lt; &quot;operator delete&quot; &lt;&lt; std::endl;</span><br><span class="line"> std::free(ptr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> Foo* m = new Foo;</span><br><span class="line"> std::cout &lt;&lt; sizeof(m) &lt;&lt; std::endl;</span><br><span class="line"> delete m;</span><br><span class="line"> return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类中的operator new默认就是static。所以加static可以，不加也是全局，可以正常使用。</p><p>这种重载的意义是和重载operator new配套。只有operator new报异常了，就会调用对应的operator delete。若没有对应的operator delete，则无法释放内存。</p><h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><p>学习网址：zh.cppreference.com</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>相比于普通数组，array容器访问速度快，安全性高，在传递方式方面，普通数组作为函数参数时，实际上是传递一个指向数组首元素的指针。而array容器作为函数参数时，实际上传递的是整个array容器的值。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">td::array&lt;int, 5&gt; myarr;</span><br><span class="line">std::array&lt;int, 5&gt; a2;</span><br><span class="line">for (int i =0;i&lt;myarr.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">std::cin &gt;&gt; myarr[i];</span><br><span class="line">&#125;</span><br><span class="line">for (auto it = myarr.begin(); it != myarr.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; &quot;\n&quot;;</span><br><span class="line">std::sort(myarr.begin(),myarr.end());//算法库</span><br><span class="line">std::ostream_iterator&lt;int&gt; output(std::cout,&quot; &quot;);</span><br><span class="line">std::reverse_copy(myarr.begin(), myarr.end(), a2.begin());</span><br><span class="line">std::reverse_copy(myarr.begin(), myarr.end(), output);</span><br><span class="line">std::array&lt;std::string, 5&gt; a3 = &#123; &quot;aefea&quot;,std::string(&quot;a&quot;) &#125;;</span><br><span class="line">for (auto&amp; s : a3)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; s &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上述代码中，sort是algorithm库中函数，能将容器内元素从大到小排序，reversecopy函数详见cppconference</p><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>能动态调整大小，存储相同类型元素<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; vec;</span><br><span class="line">std::vector&lt;int&gt; vec2(5);</span><br><span class="line">std::vector&lt;int&gt; vec3(5, 42);</span><br><span class="line">std::vector&lt;int&gt; vec4(vec3);</span><br><span class="line">vec.push_back(10);</span><br><span class="line">vec.push_back(20);</span><br><span class="line">//vec.pop_back();//删除末尾元素</span><br><span class="line">int first = vec[0]; // 使用数组下标访问元素</span><br><span class="line">int second = vec.at(1); // 使用at()方法访问元素，会检查下标是否越界</span><br><span class="line">//获取容量</span><br><span class="line">size_t size = vec.size();//获取向量大小</span><br><span class="line">size_t capacity = vec.capacity();//分配内存空间大小</span><br><span class="line">//迭代访问</span><br><span class="line">for (auto i : vec)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; i&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">for (auto it = vec.begin(); it != vec.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>data()返回值 : 指向底层元素存储的指针。对于非空容器，返回的指针与首元素地址比较相等。<br>例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void span_func(std::span&lt;const int&gt; data) // C++20 起</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;data = &quot;;</span><br><span class="line">    for (const int e : data)</span><br><span class="line">        std::cout &lt;&lt; e &lt;&lt; &#x27; &#x27;;</span><br><span class="line">    std::cout &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">std::span&lt;int&gt; s&#123;container.data(),container.size() &#125;;</span><br><span class="line">span_func(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注：span 是c++20新特性</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>双向链表<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::list&lt;int&gt; l = &#123;7,5,16,8&#125;;</span><br><span class="line">l.push_back(25);//添加末尾</span><br><span class="line">l.push_front(15);//   开头</span><br><span class="line">std::list&lt;int&gt;::iterator it = std::find(l.begin(),l.end(),16);//用迭代器找到16的位置</span><br><span class="line">if(it!=l.end())</span><br><span class="line">l.insert(it, 42);</span><br><span class="line">std::cout &lt;&lt; *it&lt;&lt;&quot;\n&quot;;</span><br><span class="line">//迭代打印</span><br><span class="line">for (auto i : l)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>还有pop_back等用法在笔记中不一 一实例了，cppconference中有实例。</p><p>list 的原理：</p><p>list 是通过双向链表实现的，每个节点都包含了指向前一个节点和后一个节点的指针。因此，插入和删除元素时只需要修改相关节点的指针即可，不需要像数组那样进行元素的移动。</p><p>由于 list 中的元素是通过指针进行连接的，因此在访问 list 中的元素时，需要通过迭代器来进行访问。迭代器是指向 list 中元素的指针，支持 ++ 操作来遍历 list 中的元素</p><h4 id="forward-list"><a href="#forward-list" class="headerlink" title="forward list"></a>forward list</h4><p>单向列表（单链表）<br>只能从一端进入和移除，所以只能从容器起始插入和删除</p><h3 id="queue-容器的适配器"><a href="#queue-容器的适配器" class="headerlink" title="queue(容器的适配器 )"></a>queue(容器的适配器 )</h3><p>队列<br>queue是一个单口进出的数据结构，没有迭代器<br>first in first out</p><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>双端队列<br>可以两边扩充</p><p>在 C++ STL 中，deque（双端队列）是一种常用的容器，它可以在两端进行插入和删除操作，并且支持随机访问。deque 内部使用一个动态数组来存储元素，可以动态调整大小以适应元素的添加和删除，同时还可以在数组的两端进行快速插入和删除操作，因此可以高效地实现队列和栈等数据结构。</p><p>简单用法例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::deque&lt;int&gt; de(10);</span><br><span class="line">/*de.push_back(5);</span><br><span class="line">de.push_front(10);*/</span><br><span class="line">std::deque&lt;int&gt;::iterator it = de.begin();</span><br><span class="line">for (it; it != de.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">int x = 0;</span><br><span class="line">std::cin &gt;&gt; x;</span><br><span class="line">*it = x;</span><br><span class="line">&#125;</span><br><span class="line">for (auto i : de)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="stack-容器的适配器"><a href="#stack-容器的适配器" class="headerlink" title="stack(容器的适配器)"></a>stack(容器的适配器)</h3><p>栈和队列都是不能直接通过构造函数分配元素数量的，必须通过封装vector来实现<br>具体例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; v(10, 0);</span><br><span class="line"> std::stack&lt;int&gt; s(v);</span><br></pre></td></tr></table></figure></p><h3 id="set-红黑树"><a href="#set-红黑树" class="headerlink" title="set 红黑树"></a>set 红黑树</h3><p>set 中存储的元素是唯一的，插入重复元素会被忽略</p><h4 id="multiset-红黑树"><a href="#multiset-红黑树" class="headerlink" title="multiset(红黑树)"></a>multiset(红黑树)</h4><p>含有 Key 类型对象有序集的容器。与 set 不同，它允许多个 Key 拥有等价的值。用关键比较函数 Compare 进行排序。搜索、插入和移除操作拥有对数复杂度。</p><h4 id="unordered-multiset-哈希表"><a href="#unordered-multiset-哈希表" class="headerlink" title="unordered_multiset(哈希表)"></a>unordered_multiset(哈希表)</h4><p>篮子不能太长，如果元素的个数大于等于篮子，篮子就要重新扩充大于等于两倍的元素个数</p><h4 id="unordered-set-哈希表）"><a href="#unordered-set-哈希表）" class="headerlink" title="unordered_set (哈希表）"></a>unordered_set (哈希表）</h4><h3 id="四个容器区别总结"><a href="#四个容器区别总结" class="headerlink" title="四个容器区别总结"></a>四个容器区别总结</h3><p>set 和 multiset 是基于红黑树实现的关联容器，可以快速插入、删除、查找元素，并且元素默认按照元素值从小到大排序，但插入、删除和查找等操作的时间复杂度为 O(log n)。</p><p>unordered_set 和 unordered_multiset 是基于哈希表实现的关联容器，可以快速插入、删除、查找元素，并且插入、删除和查找等操作的时间复杂度为 O(1)，但元素没有固定的顺序。</p><p>在选择使用哪种容器时，需要考虑元素是否需要排序以及对性能的要求。如果元素需要排序，且对性能要求不是非常高，可以选择 set 或 multiset；如果对性能要求比较高，可以选择 unordered_set 或 unordered_multiset。</p><h4 id="四个容器的用法："><a href="#四个容器的用法：" class="headerlink" title="四个容器的用法："></a>四个容器的用法：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//1.定义</span><br><span class="line">std::set&lt;int&gt; s;</span><br><span class="line">std::multiset&lt;int&gt; ms;</span><br><span class="line">std::unordered_multiset&lt;int&gt; ums;</span><br><span class="line">std::unordered_set&lt;int&gt; us;</span><br><span class="line">//2.插入</span><br><span class="line">s.insert(5);</span><br><span class="line">s.insert(2);</span><br><span class="line">ms.insert(3);</span><br><span class="line">ms.insert(4);</span><br><span class="line">/*后面两个容器也一样*/</span><br><span class="line"></span><br><span class="line">//3.查找元素</span><br><span class="line">auto it = s.find(2);//返回的是迭代器指针</span><br><span class="line">std::cout &lt;&lt; *it;</span><br><span class="line">//4.遍历</span><br><span class="line">for (auto it = s.begin(); it != s.end(); ++it) &#123;</span><br><span class="line">std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;; // 输出 set 容器中的元素</span><br><span class="line">&#125;</span><br><span class="line">for (auto it = ms.begin(); it != ms.end(); ++it) &#123;</span><br><span class="line">std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;; // 输出 multiset 容器中的元素</span><br><span class="line">&#125;</span><br><span class="line">for (auto i : ms)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; i&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">for (auto i : s)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; i&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">//5.合并</span><br><span class="line">s.merge(ms);</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>Map是C++ STL中的一个关联式容器，它提供了一种映射关系的数据结构，即一组key-value对，其中key是唯一的，value可以重复。Map中的元素是按照key的大小进行排序的，因此可以进行快速的查找和插入操作。Map支持[]和insert等操作，可以通过迭代器进行遍历。Map的底层实现一般采用红黑树，因此它的插入、删除和查找操作的时间复杂度都是O(log n)。</p><p>用法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*插入，创建，初始化,修改*/</span><br><span class="line">std::map&lt;std::string, int&gt; m&#123; &#123;&quot;CPU&quot;,10&#125; ,&#123;&quot;GPU&quot;,20&#125;&#125;;</span><br><span class="line">m.insert(std::pair&lt;std::string, int&gt;(&quot;ARM&quot;, 35));//插入</span><br><span class="line">m[&quot;ARM&quot;] = 45;</span><br><span class="line">m[&quot;Map&quot;] = 15;//插入新值</span><br><span class="line"></span><br><span class="line">/*遍历方法*/</span><br><span class="line">for (const auto&amp; [key, value] : m)</span><br><span class="line">std::cout &lt;&lt; &#x27;[&#x27; &lt;&lt; key &lt;&lt; &quot;] = &quot; &lt;&lt; value &lt;&lt; &quot;; &quot;;</span><br><span class="line"></span><br><span class="line">for (auto it = m.begin(); it != m.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h3><p>Multimap是一个允许重复键的Map，它也是一个关联式容器，提供了一种映射关系的数据结构，其中一组key-value对中的key可以重复，而value可以不重复。Multimap的元素同样是按照key的大小进行排序的，并且支持[]和insert等操作，可以通过迭代器进行遍历。Multimap的底层实现一般采用红黑树，因此它的插入、删除和查找操作的时间复杂度也都是O(log n)。</p><p>用法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//2.multimap</span><br><span class="line">std::multimap&lt;std::string, int&gt; m;</span><br><span class="line">m.insert(std::pair&lt;std::string, int&gt;(&quot;map&quot;, 10));</span><br><span class="line">m.insert(std::pair&lt;std::string, int&gt;(&quot;map&quot;, 10));</span><br><span class="line">m.insert(std::pair&lt;std::string, int&gt;(&quot;map&quot;, 10));</span><br><span class="line">//m[&quot;map&quot;] = 15;//没有[]操作符 error</span><br><span class="line">for (auto it = m.begin(); it != m.end(); it++) &#123;</span><br><span class="line">std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot; : &quot; &lt;&lt; it-&gt;second &lt;&lt;std:: endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Multimap的用法和Map类似，只是插入操作不会覆盖已有的键值对。</p><h3 id="unordered-multimap"><a href="#unordered-multimap" class="headerlink" title="unordered_multimap"></a>unordered_multimap</h3><p>unordered_multimap是一个允许重复键的unordered_map，它也是一个哈希表，提供了一种映射关系的数据结构，其中一组key-value对中的key可以重复，而value可以不重复。unordered_multimap中的元素是按照哈希值进行存储的，因此查找和插入操作的时间复杂度是O(1)。</p><p>用法：<br>unordered_map的用法和Map类似，只是底层实现不同，插入操作的时间复杂度为O(1)。</p><h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><p>unordered_map是C++ STL中的一个哈希表，它提供了一种映射关系的数据结构，其中一组key-value对中的key是唯一的，而value可以重复。unordered_map中的元素是按照哈希值进行存储的，因此查找和插入操作的时间复杂度是O(1)。</p><p>用法：<br>unordered_multimap的用法和unordered_map类似，只是允许键值对中的键重复。</p><h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><p>Map和Multimap都是基于红黑树实现的，而unordered_map和unordered_multimap都是基于哈希表实现的。因此，Map和Multimap的插入、删除和查找操作的时间复杂度都是O(log n)，而unordered_map和unordered_multimap的插入、删除和查找操作的时间复杂度都是O(1)。另外，Map和Multimap中的元素是按照key的大小进行排序的，而unordered_map和unordered_multimap中的元素是按照哈希值进行存储的，因此它们的遍历顺序可能不同。此外，Multimap和unordered_multimap允许重复键，而Map和unordered_map不允许重复键。</p><h3 id="补充stl算法"><a href="#补充stl算法" class="headerlink" title="补充stl算法"></a>补充stl算法</h3><h4 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound"></a>upper_bound</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; v = &#123;1, 2, 3, 4, 4, 6, 7, 8, 9&#125;;</span><br><span class="line">  auto it = std::upper_bound(v.begin(), v.end(), 4);</span><br><span class="line">  if (it != v.end()) &#123;</span><br><span class="line">      std::cout &lt;&lt; &quot;The first element greater than 4 is: &quot; &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      std::cout &lt;&lt; &quot;No element greater than 4&quot; &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>std::upper_bound将返回一个迭代器，指向第一个大于value的元素。如果不存在这样的元素，std::upper_bound将返回last。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cpp知识补充&quot;&gt;&lt;a href=&quot;#cpp知识补充&quot; class=&quot;headerlink&quot; title=&quot;cpp知识补充&quot;&gt;&lt;/a&gt;cpp知识补充&lt;/h1&gt;&lt;p&gt;01 - 侯捷 - C++面向对象高级开发（上下两部曲）&lt;/p&gt;
&lt;p&gt;02 - 侯捷 - STL标</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>GDB调试</title>
    <link href="https://null0x0f.github.io/posts/46594b90.html"/>
    <id>https://null0x0f.github.io/posts/46594b90.html</id>
    <published>2023-04-15T11:31:20.000Z</published>
    <updated>2023-06-18T08:25:54.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h1><h2 id="编译c程序"><a href="#编译c程序" class="headerlink" title="编译c程序"></a>编译c程序</h2><p>gcc test.c -o test.out</p><h2 id="生成debug-info文件"><a href="#生成debug-info文件" class="headerlink" title="生成debug info文件"></a>生成debug info文件</h2><p>gcc -g test.c -o test.out</p><h2 id="打断点"><a href="#打断点" class="headerlink" title="打断点"></a>打断点</h2><p>b main<br>b path :行数<br>r<br>n 不进函数体单个执行<br>s  进函数单个执行</p><h2 id="看断点"><a href="#看断点" class="headerlink" title="看断点"></a>看断点</h2><p>info b 看断点<br>d 行数  删除断点<br>c continue</p><p>bt 看函数调用栈</p><h2 id="监视"><a href="#监视" class="headerlink" title="监视"></a>监视</h2><p>watch 变量</p><p>info r 看寄存器的值</p><h2 id="查看代码或汇编"><a href="#查看代码或汇编" class="headerlink" title="查看代码或汇编"></a>查看代码或汇编</h2><p>layout src  查看代码<br>layout asm 查看汇编 </p><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ gdb 调试</span><br><span class="line">(gdb) break 10   //在第十行打断点</span><br><span class="line">Breakpoint 1 at 0x4005f4: file my_program.cpp, line 10.  //第一个断点，在地址 0x4005f4处    file 后面显示的是打在哪个文件  哪一行</span><br><span class="line">(gdb) run      </span><br><span class="line">Starting program: /path/to/my_program </span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at my_program.cpp:10    //第一个断点打在 main()函数，是在my_program.cpp这个源文件的第十行</span><br><span class="line"></span><br><span class="line">10      int x = 0;</span><br><span class="line">(gdb) print x</span><br><span class="line">$1 = 0    //检验x的值是0</span><br><span class="line">(gdb) step  //进函数个体执行</span><br><span class="line">11      x = 1;</span><br><span class="line">(gdb) print x</span><br><span class="line">$2 = 0     </span><br><span class="line">(gdb) next  //不进函数个体执行</span><br><span class="line">12      x = 2;</span><br><span class="line">(gdb) print x</span><br><span class="line">$3 = 1</span><br><span class="line">(gdb) continue</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GDB调试&quot;&gt;&lt;a href=&quot;#GDB调试&quot; class=&quot;headerlink&quot; title=&quot;GDB调试&quot;&gt;&lt;/a&gt;GDB调试&lt;/h1&gt;&lt;h2 id=&quot;编译c程序&quot;&gt;&lt;a href=&quot;#编译c程序&quot; class=&quot;headerlink&quot; title=&quot;编译c</summary>
      
    
    
    
    
  </entry>
  
</feed>
