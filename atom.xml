<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NULL&#39;blog</title>
  
  
  <link href="https://null0x0f.github.io/atom.xml" rel="self"/>
  
  <link href="https://null0x0f.github.io/"/>
  <updated>2023-05-05T06:14:03.367Z</updated>
  <id>https://null0x0f.github.io/</id>
  
  <author>
    <name>NULL+</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>c plus plus</title>
    <link href="https://null0x0f.github.io/posts/d99aa42e.html"/>
    <id>https://null0x0f.github.io/posts/d99aa42e.html</id>
    <published>2023-04-24T11:22:45.000Z</published>
    <updated>2023-05-05T06:14:03.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cpp知识补充"><a href="#cpp知识补充" class="headerlink" title="cpp知识补充"></a>cpp知识补充</h1><p>01 - 侯捷 - C++面向对象高级开发（上下两部曲）</p><p>02 - 侯捷 - STL标准库和泛型编程</p><p>03 - 侯捷 - C++设计模式</p><p>04 - 侯捷 - C++新标准C++11&amp;14</p><p>05 - 侯捷 - C++内存管理机制</p><p>06 - 侯捷 C++ Startup 揭密：C++ 程序的生前和死后</p><p>07、算法原理与实践（选修）</p><p>08、系统设计与实践（选修）</p><p>书籍:c++ primer<br>   effective modern c++<br>   stl源码剖析</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>拿来当c++知识点补充库，顺序不是按照学习的顺序，是感觉哪个不会了，看书或视频补充知识点。</p><h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><p>定义命名空间<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//如果不引入 using namespace std;就需要我们显示引入,例如std::cout</span><br><span class="line">namespace a</span><br><span class="line">&#123;</span><br><span class="line">  int a = 10;</span><br><span class="line">&#125;</span><br><span class="line">namespace b</span><br><span class="line">&#123;</span><br><span class="line">int a = 20;</span><br><span class="line">namespace c</span><br><span class="line">&#123;</span><br><span class="line">  int a = 30;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>使用命名空间<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  using namespace a;</span><br><span class="line">using namespace b;</span><br><span class="line">cout &lt;&lt; a::a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; b::a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; b::c::a &lt;&lt; endl;</span><br><span class="line">using b::c::a;</span><br><span class="line">cout &lt;&lt; a;</span><br><span class="line">  </span><br><span class="line">  system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不使用using namespace std 原因：<br>如果没有命名空间，这些变量、函数、类的名称将都存在于全局命名空间中，当定义了一个函数名与标准库中函数名相同时，就会发生冲突。<br>比如，我们在自己的程序中定义了一个Stack类，而我们程序中使用的某个库中也可能定义了一个同名的类，此时名称就冲突了。</p><h2 id="顶层const和底层const"><a href="#顶层const和底层const" class="headerlink" title="顶层const和底层const"></a>顶层const和底层const</h2><p>const修饰的变量不可以改变就是顶层const：<br>const int a = 10;<br>底层const：<br>const int &amp;ra = 10;</p><p>c++ primer :当执行对象的拷贝操作时，常量的顶层const不受什么影响，而底层const必须一致</p><p> const引用理解:<br> 1.引用不是对象且不进行拷贝<br> 2.常量引用如果在左侧，右侧可以接任何东西<br> 3.非常量引用 = 常量  error<br> 4.引用如果在等号右侧请忽略引用<br> 5.非常量 = 常引用</p><p>判断方法:<br><img src="const1.png" alt="const1"><br><img src="const2.png" alt="const2"></p><p>代码详解:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">int i = 0;</span><br><span class="line">const int p = 10;//顶层const(不能被修改)</span><br><span class="line">const int* p1 = &amp;p;</span><br><span class="line">p1 = &amp;i;</span><br><span class="line">//底层const 允许修改p1的值   const 修饰的是int 不能改变的是 *p1  int *p1是个指针，地址没变，里面值改变无所谓   const修饰的是什么,p1就指向的是什么 *p就相当于（const int）*p</span><br><span class="line">    int* const p2 =&amp;i;//顶层const p2的值不允许被修改 p2是个指针，里面存放的是地址，地址是不可以改变的，值是可以改变的。  const  int*p2  然后你可以通过改变p2指向这个内存地址里的值,来改变p2读出来的值</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>const int* p1 = &p;</p><p>p1是一个指向const int类型的指针变量。<br>&amp;p是一个指向int类型变量p的地址。<br>通过将&amp;p赋值给p1，p1成为了一个指向p的const int类型的指针。<br>这意味着p1指向的int类型的数据是只读的，不能通过p1来修改。<br>int* const p2 = &i;</p><p>p2是一个指向int类型的常量指针变量。<br>&amp;i是一个指向int类型变量i的地址。<br>通过将&amp;i赋值给p2，p2成为了一个指向i的int类型的常量指针。<br>这意味着p2指向的int类型数据可以修改，但是p2本身的指向是不可变的，即p2不能指向其他的地址。</p><h2 id="register-加强"><a href="#register-加强" class="headerlink" title="register 加强"></a>register 加强</h2><p>register 关键字请求编译器将局部变量存储于寄存器中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">  std::cout&lt;&lt;&amp;a&lt;&lt;endl;</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="引用剖析"><a href="#引用剖析" class="headerlink" title="引用剖析"></a>引用剖析</h2><h3 id="引用语法"><a href="#引用语法" class="headerlink" title="引用语法"></a>引用语法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">   <span class="type">int</span> &amp;b = a;<span class="comment">//b就是a的别名 int *const b = &amp;a</span></span><br><span class="line">   b= <span class="number">11</span>;<span class="comment">//*b = 11</span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用本质"><a href="#引用本质" class="headerlink" title="引用本质"></a>引用本质</h3><p>引用在c++内部实现是一个常量指针<br>Type&amp; name&lt;——&gt;Type * const name</p><h3 id="函数返回值是引用"><a href="#函数返回值是引用" class="headerlink" title="函数返回值是引用"></a>函数返回值是引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> *<span class="title">get_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回的是本身的一个副本(20)</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">get_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="type">int</span> a2 = <span class="built_in">get_2</span>();<span class="comment">//20</span></span><br><span class="line">   <span class="type">int</span> &amp;a3 = <span class="built_in">get_2</span>();<span class="comment">//返回的是a的本身 地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若返回静态变量或全局变量<br>可以成为其他引用初始值<br>既可以作为右值使用，也可以作为左值使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">g1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">g2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">  a++;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">g1</span>() =<span class="number">100</span>;<span class="comment">//error </span></span><br><span class="line">   <span class="built_in">g2</span>() = <span class="number">100</span>;<span class="comment">//返回的是变量本身 g2()返回的a当左值使用 </span></span><br><span class="line">   <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h2><p> 用来代替宏代码片段<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> inline void fun() </span><br><span class="line">&#123;</span><br><span class="line">   int a = 10;</span><br><span class="line">   cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> #define Myfunc(a,b)((a)&lt;(b)？(a):(b))</span><br><span class="line"> inline int myfunc(int a,int b) </span><br><span class="line">&#123;</span><br><span class="line">   return a&lt;b?a:b</span><br><span class="line">&#125;</span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line"> int c1 = myfunc(++a,b)//a=2 b = 3 c =2</span><br><span class="line"> int c2 = Myfunc(++a,b)//==&gt;宏展开((++a)&lt;(b)?(++a):(b))</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 内联不能做声明，必须和函数体实现写在一块<br>adsd</p><h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p> 构造函数：完成对属性的初始化工作（先创建的对象先构造）<br> 析构函数：先创建的对象后释放（栈机制）</p><h3 id="构造函数分类"><a href="#构造函数分类" class="headerlink" title="构造函数分类"></a>构造函数分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class test</span><br><span class="line">&#123;</span><br><span class="line">  private:</span><br><span class="line">  int a,b,c,d;</span><br><span class="line">  public:</span><br><span class="line">  test()//无参构造</span><br><span class="line">  &#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  test(int a,int b)//有参构造</span><br><span class="line">  &#123;</span><br><span class="line">     this-&gt;a = a;</span><br><span class="line">     this-&gt;b = b;</span><br><span class="line">  &#125;</span><br><span class="line">  test(const test&amp; obj)//赋值构造函数</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">   test t2//无参构造</span><br><span class="line">   test t(2,4);//有参调用</span><br><span class="line">   test t1(t);//拷贝构造</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深拷贝和浅拷贝问题"><a href="#深拷贝和浅拷贝问题" class="headerlink" title="深拷贝和浅拷贝问题"></a>深拷贝和浅拷贝问题</h3><h4 id="浅拷贝分析"><a href="#浅拷贝分析" class="headerlink" title="浅拷贝分析"></a>浅拷贝分析</h4><p>默认的拷贝构造函数，编译器提供<br>把对象1的属性拷贝给对象二<br>把指针变量的值拷贝给对象二，并没有把指针变量所指向的内存空间的数据拷贝过来<br>两个指针变量指向同一个空间<br><img src="24.png" alt="24"></p><p>obj2析构函数 把指向的内存空间析构<br>obj2 指向null，obj1仍然指向堆里被释放的内存空间。<br>obj1再析构，还是析构的obj2之前析构的那一块空间，，结果析构两次，造成空间的coredump</p><p>coredump出现原因:<br><img src="coredump.png" alt="coredump"></p><h4 id="等号操作也是浅拷贝操作"><a href="#等号操作也是浅拷贝操作" class="headerlink" title="等号操作也是浅拷贝操作"></a>等号操作也是浅拷贝操作</h4><h2 id="临时对象"><a href="#临时对象" class="headerlink" title="临时对象"></a>临时对象</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>构造之后马上析构</p><h3 id="构造函数中调用构造函数"><a href="#构造函数中调用构造函数" class="headerlink" title="构造函数中调用构造函数"></a>构造函数中调用构造函数</h3><p>危险行为</p><h2 id="new-和delete"><a href="#new-和delete" class="headerlink" title="new 和delete"></a>new 和delete</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int *arr = new int[10];</span><br><span class="line">delete []arr;</span><br><span class="line"></span><br><span class="line">//动态分配对象</span><br><span class="line">object *pt = new object;</span><br><span class="line">delete pt;</span><br></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="友元函数和友元类"><a href="#友元函数和友元类" class="headerlink" title="友元函数和友元类"></a>友元函数和友元类</h3><h4 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">friend void modify(A* pa,int _a);</span><br><span class="line">A(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;a = a;</span><br><span class="line">this-&gt;b = b;</span><br><span class="line">&#125;</span><br><span class="line">void geta()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;this-&gt;a;</span><br><span class="line">&#125;</span><br><span class="line">//声明位置和public和private没关系</span><br><span class="line">private:</span><br><span class="line">int a;</span><br><span class="line">int b;</span><br><span class="line">&#125;;</span><br><span class="line">void modify(A* pa,int _a)</span><br><span class="line">&#123;</span><br><span class="line">pa-&gt;a = _a;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">A a(5, 3);</span><br><span class="line">modify(&amp;a, 100);</span><br><span class="line">a.geta();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h4><h4 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h4><p>这两个都写在vs里了<br><img src="重载.png" alt="重载"></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h3 id="访问父类的语法和概念"><a href="#访问父类的语法和概念" class="headerlink" title="访问父类的语法和概念"></a>访问父类的语法和概念</h3><h3 id="派生类的访问控制"><a href="#派生类的访问控制" class="headerlink" title="派生类的访问控制"></a>派生类的访问控制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">类的单个类访问控制</span><br><span class="line">//public 修饰地成员变量方法在类的内部 类的外部都能使用</span><br><span class="line">//protected 修饰的成员变量方法，在类的内部使用，在继承的子类中可用</span><br><span class="line">//private 修饰地成员变量方法只能在类的内部使用 类的外部不行</span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">  int a;</span><br><span class="line">  void printT()</span><br><span class="line">  &#123;</span><br><span class="line">  cout&lt;&lt;&quot;printT&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  protected:</span><br><span class="line">  int b;</span><br><span class="line">  private:</span><br><span class="line">  int c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class test:public Test</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">   void user()</span><br><span class="line">   &#123;</span><br><span class="line">     a = 0;//ok</span><br><span class="line">     b= 0;//ok </span><br><span class="line">     c = 0;//error 私有变量</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="派生类访问.png" alt="派生类访问"><br>protect 关键字修饰变量使用，是为了继承</p><h3 id="继承中构造和析构"><a href="#继承中构造和析构" class="headerlink" title="继承中构造和析构"></a>继承中构造和析构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//赋值兼容性原则</span><br><span class="line">//1.基类指针(引用)指向子类对象 可以调用父类方法</span><br><span class="line">class Parent</span><br><span class="line">&#123;</span><br><span class="line">  private:</span><br><span class="line">  int a;</span><br><span class="line">  int b;</span><br><span class="line">  public:</span><br><span class="line">  Parent(int a1,int b1):a(a1),b(b1)&#123;&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">class child</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">int c;</span><br><span class="line">public:</span><br><span class="line">child(int a,int b,int c1):parent(a,b),c(c1)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="继承1.png" alt="继承1"><br><img src="继承2.png" alt="继承2"></p><h3 id="继承和虚函数"><a href="#继承和虚函数" class="headerlink" title="继承和虚函数"></a>继承和虚函数</h3><p>virtual函数:你希望derived class 重新定义它，且你对他已有默认定义<br>pure virtual 函数:erived class 重新定义它，且你对他没有默认定义</p><h3 id="复合和继承"><a href="#复合和继承" class="headerlink" title="复合和继承"></a>复合和继承</h3><h3 id="委托和继承"><a href="#委托和继承" class="headerlink" title="委托和继承"></a>委托和继承<img src="delegation.png" alt="delegation"></h3><p><img src="委托2.png" alt="委托2"></p><h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class person//抽象基类(类似于接口)</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">string name;</span><br><span class="line">int height;</span><br><span class="line">int age;</span><br><span class="line">public:</span><br><span class="line">virtual void getinfo() const = 0;//纯虚函数</span><br><span class="line">virtual void action() = 0;</span><br><span class="line">string getname()</span><br><span class="line">&#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">person(string&amp; s, int h,int a) :name(s), height(h),age(a) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class dancer :public person</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">string danceaction;</span><br><span class="line">public:</span><br><span class="line">dancer(string na,int h, int a, string ac) :person(na,h,a)</span><br><span class="line">&#123;</span><br><span class="line">danceaction = ac;</span><br><span class="line">&#125;</span><br><span class="line">void getinfo() const</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;name:&quot; &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;height:&quot; &lt;&lt; height &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;age:&quot; &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;danceaction:&quot; &lt;&lt;danceaction&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void action()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;dance&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。<br>因此，如果一个 ABC 的子类需要被实例化，则必须实现每个纯虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。<br>可用于实例化对象的类被称为具体类。<a href="https://www.runoob.com/cplusplus/cpp-interfaces.html">https://www.runoob.com/cplusplus/cpp-interfaces.html</a></p><h3 id="继承的动态内存分配"><a href="#继承的动态内存分配" class="headerlink" title="继承的动态内存分配"></a>继承的动态内存分配</h3><p>基类使用动态内存分配，派生类不使用动态内存分配。<br>可以省略构造函数和析构函数中的内存分配和释放操作，直接继承基类中的构造和析构函数。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">    Base(const char* str) &#123;</span><br><span class="line">        data_ = new char[strlen(str) + 1];</span><br><span class="line">        strcpy(data_, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual ~Base() &#123;</span><br><span class="line">        delete[] data_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const char* getData() const &#123;</span><br><span class="line">        return data_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    char* data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 派生类，不使用动态内存分配</span><br><span class="line">class Derived : public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    Derived(const char* str, int value)</span><br><span class="line">        : Base(str), value_(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    int getValue() const &#123;</span><br><span class="line">        return value_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int value_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>基类使用动态内存分配，派生类也使用动态内存分配<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class BASE</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">char* base;</span><br><span class="line">public:</span><br><span class="line">BASE(const char *str)</span><br><span class="line">&#123;</span><br><span class="line">base = new char[strlen(str) + 1];</span><br><span class="line">strcpy(base, str);</span><br><span class="line">&#125;</span><br><span class="line">virtual ~BASE()</span><br><span class="line">&#123;</span><br><span class="line">delete[]base;</span><br><span class="line">&#125;</span><br><span class="line">BASE&amp; operator=(const BASE&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">if (this == &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line">delete[]base;</span><br><span class="line">base = new char[strlen(str.base) + 1];</span><br><span class="line">strcpy(base,str.base);</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class derived :public BASE</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">char* dervived;</span><br><span class="line">public:</span><br><span class="line">derived(const char* str):BASE(str)</span><br><span class="line">&#123;</span><br><span class="line">dervived = new char[strlen(str) + 1];</span><br><span class="line">strcpy(dervived, str);</span><br><span class="line">&#125;</span><br><span class="line">derived&amp; operator=(const derived&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">if (this == &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line">delete[]dervived;</span><br><span class="line">BASE::operator=(str);</span><br><span class="line">dervived = new char[strlen(str.dervived) + 1];</span><br><span class="line">strcpy(dervived, str.dervived);</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line">~derived()</span><br><span class="line">&#123;</span><br><span class="line">delete[] dervived;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="conversion-function"><a href="#conversion-function" class="headerlink" title="conversion function"></a>conversion function</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">fraction</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> numrator;</span><br><span class="line"><span class="type">int</span> denominator;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">fraction</span>(<span class="type">int</span> num, <span class="type">int</span> den = <span class="number">1</span>) :<span class="built_in">numrator</span>(num), <span class="built_in">denominator</span>(den) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">double</span>(numrator * <span class="number">1.0</span> / denominator);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> d = f + <span class="number">4</span>;</span><br><span class="line">cout &lt;&lt; d;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>double d = 4 + f;这一语句会首先查找Fraction是否有重载操作符 operator + (double, Fraction) 的函数，由于没有，所以调用会转换函数operator double() const。</p><p>另外，转换函数除了可以将一个类型转换成另一个基本类型，还可以将一个类型转换成另一个复合类型（例如string类型）。</p><h4 id="non-explicit-one-argument-ctor"><a href="#non-explicit-one-argument-ctor" class="headerlink" title="non -explicit-one-argument ctor"></a>non -explicit-one-argument ctor</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Fraction </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Fraction(int num, int den=1) :</span><br><span class="line">        m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Fraction operator + (const Fraction&amp; f) &#123;</span><br><span class="line">        return Fraction(...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int m_numerator;  // 分子</span><br><span class="line">    int m_denominator;  // 分母</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Fraction f(3, 5);</span><br><span class="line">Fraction d2 = f + 4; </span><br></pre></td></tr></table></figure><p>只要一个实参就够了，也可以传两个实参。将别的东西转换成这个类对象</p><h4 id="conversion-function-vs-non-explicit-one-argument-constructor"><a href="#conversion-function-vs-non-explicit-one-argument-constructor" class="headerlink" title="conversion function vs. non-explicit-one-argument constructor"></a>conversion function vs. non-explicit-one-argument constructor</h4><h4 id="explicit-one-argument-constructor"><a href="#explicit-one-argument-constructor" class="headerlink" title="explicit-one-argument constructor"></a>explicit-one-argument constructor</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Fraction </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    explicit Fraction(int num, int den=1) :</span><br><span class="line">        m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    operator double() const &#123;</span><br><span class="line">        return (double) (m_numerator / m_denominator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Fraction operator + (const Fraction&amp; f) &#123;</span><br><span class="line">        return Fraction(...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int m_numerator;  // 分子</span><br><span class="line">    int m_denominator;  // 分母</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Fraction f(3, 5);</span><br><span class="line">Fraction d2 = f + 4;  // [Error] convertion from double to Fraction requested</span><br></pre></td></tr></table></figure><p>由于在构造函数前面增加了explicit关键字，所以不能将4转换成Fraction类型；也不能先将f转换成double类型，与4相加后再将double转换成Fraction。</p><h2 id="pointer-like-classes"><a href="#pointer-like-classes" class="headerlink" title="pointer like classes"></a>pointer like classes</h2><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>智能指针是你在堆栈上声明的类模板，并可通过使用指向某个堆分配的对象的原始指针进行初始化。 在初始化智能指针后，它将拥有原始的指针。 这意味着智能指针负责删除原始指针指定的内存。 智能指针析构函数包括要删除的调用，并且由于在堆栈上声明了智能指针，当智能指针超出范围时将调用其析构函数，尽管堆栈上的某处将进一步引发异常。</p><p>C++ 中有三种常用的智能指针：</p><ol><li><p>unique_ptr：独占所有权的智能指针，不能被复制，只能被移动。当 unique_ptr 超出作用域时，它所指向的对象会被自动释放。</p></li><li><p>shared_ptr：共享所有权的智能指针，可以被多个 shared_ptr 共享。当最后一个 shared_ptr 超出作用域时，它所指向的对象会被自动释放。</p></li><li><p>weak_ptr：弱引用的智能指针，不能直接访问所指向的对象，必须通过 lock() 函数获得一个 shared_ptr 才能访问。weak_ptr 不会增加所指对象的引用计数，因此不会影响所指对象的生命周期。</p></li></ol><h4 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h4><p>用法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;memory&gt;</span><br><span class="line">shared_ptr&lt;double&gt; p1(new double(42));</span><br><span class="line">shared_ptr&lt;int&gt;p2= make_shared&lt;int&gt;(42);</span><br></pre></td></tr></table></figure><br>拷贝和赋值<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">auto r = make_shared&lt;int&gt;(42);//r指向int只有一个引用</span><br><span class="line">r=q;//给r赋值</span><br><span class="line">    //q指向的对象引用次数++</span><br><span class="line">    //r指向对象引用次数--</span><br><span class="line">    //r没有引用了，就会自动释放</span><br></pre></td></tr></table></figure><br>离开作用域，它指向内存也会自动释放<br>但是如果有其他智能指针也指向这块内存，他就不会被释放<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void use_factory(T arg)</span><br><span class="line">&#123;</span><br><span class="line">   shared_ptr&lt;Foo&gt; p = factory(arg);</span><br><span class="line">   return p;//引用计数增加</span><br><span class="line">&#125;//离开作用域但不会被释放</span><br></pre></td></tr></table></figure></p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><h2 id="fuction-like-classes"><a href="#fuction-like-classes" class="headerlink" title="fuction like classes"></a>fuction like classes</h2><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><h3 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板<img src="成员模板.png" alt="成员模板" style="zoom:200%;" /></h3><h3 id="模板特化"><a href="#模板特化" class="headerlink" title="模板特化"></a>模板特化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">template&lt;&gt;</span><br><span class="line">struct hash&lt;char&gt;</span><br><span class="line">&#123;</span><br><span class="line"> size_t operator()(char x) const</span><br><span class="line">&#123;</span><br><span class="line">   return x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;&gt;</span><br><span class="line">struct hash&lt;int&gt;</span><br><span class="line">&#123;</span><br><span class="line"> size_t operator()(int x) const</span><br><span class="line">&#123;</span><br><span class="line">   return x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;&gt;</span><br><span class="line">struct hash&lt;long&gt;</span><br><span class="line">&#123;</span><br><span class="line"> size_t operator()(long x) const</span><br><span class="line">&#123;</span><br><span class="line">   return x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="偏特化-局部特化"><a href="#偏特化-局部特化" class="headerlink" title="偏特化(局部特化)"></a>偏特化(局部特化)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T,class alloc&gt;</span><br><span class="line"> class name</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class alloc&gt;</span><br><span class="line">class name&lt;bool, alloc&gt; </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>范围的偏<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">c</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">c</span>&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>如果使用者使用的是指针就用第二个模板<br>如果不是指针，用的是第一个模板</p><h3 id="模板模板参数"><a href="#模板模板参数" class="headerlink" title="模板模板参数"></a>模板模板参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T,template&lt;class T&gt; class smartptr&gt;</span><br><span class="line"></span><br><span class="line">//第一个参数是 T类型 ，第二个参数是一个smartptr，它可以指定一个T类型变量</span><br><span class="line">class XCls</span><br><span class="line">&#123;</span><br><span class="line"> private:</span><br><span class="line"> smartptr&lt;T&gt; sp;</span><br><span class="line"> public:</span><br><span class="line"> XCls():sp(new T)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">XCls&lt;string,shared_ptr&gt; p1;</span><br></pre></td></tr></table></figure><h2 id="三个主题"><a href="#三个主题" class="headerlink" title="三个主题"></a>三个主题</h2><h3 id="pack"><a href="#pack" class="headerlink" title="pack"></a>pack</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T,typename...Types&gt;</span><br><span class="line">void print(const T&amp;firstArg,const Type&amp;...args)</span><br><span class="line">&#123;</span><br><span class="line">   cout&lt;&lt;firstArg&lt;&lt;endl;</span><br><span class="line">   print(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用sizeof…(args)可以知道包有多少</p><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>auto声明变量必须要赋值</p><h3 id="ranged-base-for"><a href="#ranged-base-for" class="headerlink" title="ranged-base for"></a>ranged-base for</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;double&gt; vec;</span><br><span class="line">for(auto elem:vec)</span><br><span class="line">&#123;</span><br><span class="line">  cout&lt;&lt;elem&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(auto&amp; elem:vec)</span><br><span class="line">&#123;</span><br><span class="line">  elem*=3;</span><br><span class="line">&#125;//改变原来vec里的值</span><br></pre></td></tr></table></figure><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int x = 0;</span><br><span class="line">int* p = &amp;x;</span><br><span class="line">int&amp; r =x;//r代表x,r不能代表其他的了</span><br><span class="line">int x2 = 5;</span><br><span class="line">r = x2;//r不能代表x，现在r,x都是5</span><br><span class="line">int&amp; r2 =r;</span><br></pre></td></tr></table></figure><p>reference一定要有初值，只能代表一个，不能代表其他</p><p>32位电脑指针占四个字节</p><p>参数传递</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h2 id="重载new-delete"><a href="#重载new-delete" class="headerlink" title="重载new(),delete()"></a>重载new(),delete()</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line"> void* operator new(std::size_t size)</span><br><span class="line"> &#123;</span><br><span class="line">  std::cout &lt;&lt; &quot;operator new&quot; &lt;&lt; std::endl;</span><br><span class="line">  return std::malloc(size);</span><br><span class="line"> &#125;</span><br><span class="line"> void operator delete(void* ptr)</span><br><span class="line">&#123;</span><br><span class="line"> std::cout &lt;&lt; &quot;operator delete&quot; &lt;&lt; std::endl;</span><br><span class="line"> std::free(ptr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> Foo* m = new Foo;</span><br><span class="line"> std::cout &lt;&lt; sizeof(m) &lt;&lt; std::endl;</span><br><span class="line"> delete m;</span><br><span class="line"> return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类中的operator new默认就是static。所以加static可以，不加也是全局，可以正常使用。</p><p>这种重载的意义是和重载operator new配套。只有operator new报异常了，就会调用对应的operator delete。若没有对应的operator delete，则无法释放内存。</p><h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><p>学习网址：zh.cppreference.com</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>相比于普通数组，array容器访问速度快，安全性高，在传递方式方面，普通数组作为函数参数时，实际上是传递一个指向数组首元素的指针。而array容器作为函数参数时，实际上传递的是整个array容器的值。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">td::array&lt;int, 5&gt; myarr;</span><br><span class="line">std::array&lt;int, 5&gt; a2;</span><br><span class="line">for (int i =0;i&lt;myarr.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">std::cin &gt;&gt; myarr[i];</span><br><span class="line">&#125;</span><br><span class="line">for (auto it = myarr.begin(); it != myarr.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; &quot;\n&quot;;</span><br><span class="line">std::sort(myarr.begin(),myarr.end());//算法库</span><br><span class="line">std::ostream_iterator&lt;int&gt; output(std::cout,&quot; &quot;);</span><br><span class="line">std::reverse_copy(myarr.begin(), myarr.end(), a2.begin());</span><br><span class="line">std::reverse_copy(myarr.begin(), myarr.end(), output);</span><br><span class="line">std::array&lt;std::string, 5&gt; a3 = &#123; &quot;aefea&quot;,std::string(&quot;a&quot;) &#125;;</span><br><span class="line">for (auto&amp; s : a3)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; s &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上述代码中，sort是algorithm库中函数，能将容器内元素从大到小排序，reversecopy函数详见cppconference</p><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>能动态调整大小，存储相同类型元素<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; vec;</span><br><span class="line">std::vector&lt;int&gt; vec2(5);</span><br><span class="line">std::vector&lt;int&gt; vec3(5, 42);</span><br><span class="line">std::vector&lt;int&gt; vec4(vec3);</span><br><span class="line">vec.push_back(10);</span><br><span class="line">vec.push_back(20);</span><br><span class="line">//vec.pop_back();//删除末尾元素</span><br><span class="line">int first = vec[0]; // 使用数组下标访问元素</span><br><span class="line">int second = vec.at(1); // 使用at()方法访问元素，会检查下标是否越界</span><br><span class="line">//获取容量</span><br><span class="line">size_t size = vec.size();//获取向量大小</span><br><span class="line">size_t capacity = vec.capacity();//分配内存空间大小</span><br><span class="line">//迭代访问</span><br><span class="line">for (auto i : vec)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; i&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">for (auto it = vec.begin(); it != vec.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>data()返回值 : 指向底层元素存储的指针。对于非空容器，返回的指针与首元素地址比较相等。<br>例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void span_func(std::span&lt;const int&gt; data) // C++20 起</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;data = &quot;;</span><br><span class="line">    for (const int e : data)</span><br><span class="line">        std::cout &lt;&lt; e &lt;&lt; &#x27; &#x27;;</span><br><span class="line">    std::cout &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">std::span&lt;int&gt; s&#123;container.data(),container.size() &#125;;</span><br><span class="line">span_func(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注：span 是c++20新特性</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>双向链表<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::list&lt;int&gt; l = &#123;7,5,16,8&#125;;</span><br><span class="line">l.push_back(25);//添加末尾</span><br><span class="line">l.push_front(15);//   开头</span><br><span class="line">std::list&lt;int&gt;::iterator it = std::find(l.begin(),l.end(),16);//用迭代器找到16的位置</span><br><span class="line">if(it!=l.end())</span><br><span class="line">l.insert(it, 42);</span><br><span class="line">std::cout &lt;&lt; *it&lt;&lt;&quot;\n&quot;;</span><br><span class="line">//迭代打印</span><br><span class="line">for (auto i : l)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>还有pop_back等用法在笔记中不一 一实例了，cppconference中有实例。</p><p>list 的原理：</p><p>list 是通过双向链表实现的，每个节点都包含了指向前一个节点和后一个节点的指针。因此，插入和删除元素时只需要修改相关节点的指针即可，不需要像数组那样进行元素的移动。</p><p>由于 list 中的元素是通过指针进行连接的，因此在访问 list 中的元素时，需要通过迭代器来进行访问。迭代器是指向 list 中元素的指针，支持 ++ 操作来遍历 list 中的元素</p><h4 id="forward-list"><a href="#forward-list" class="headerlink" title="forward list"></a>forward list</h4><p>单向列表（单链表）<br>只能从一端进入和移除，所以只能从容器起始插入和删除</p><h3 id="queue-容器的适配器"><a href="#queue-容器的适配器" class="headerlink" title="queue(容器的适配器 )"></a>queue(容器的适配器 )</h3><p>队列<br>queue是一个单口进出的数据结构，没有迭代器<br>first in first out</p><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>双端队列<br>可以两边扩充</p><p>在 C++ STL 中，deque（双端队列）是一种常用的容器，它可以在两端进行插入和删除操作，并且支持随机访问。deque 内部使用一个动态数组来存储元素，可以动态调整大小以适应元素的添加和删除，同时还可以在数组的两端进行快速插入和删除操作，因此可以高效地实现队列和栈等数据结构。</p><p>简单用法例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::deque&lt;int&gt; de(10);</span><br><span class="line">/*de.push_back(5);</span><br><span class="line">de.push_front(10);*/</span><br><span class="line">std::deque&lt;int&gt;::iterator it = de.begin();</span><br><span class="line">for (it; it != de.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">int x = 0;</span><br><span class="line">std::cin &gt;&gt; x;</span><br><span class="line">*it = x;</span><br><span class="line">&#125;</span><br><span class="line">for (auto i : de)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="stack-容器的适配器"><a href="#stack-容器的适配器" class="headerlink" title="stack(容器的适配器)"></a>stack(容器的适配器)</h3><p>栈和队列都是不能直接通过构造函数分配元素数量的，必须通过封装vector来实现<br>具体例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; v(10, 0);</span><br><span class="line"> std::stack&lt;int&gt; s(v);</span><br></pre></td></tr></table></figure></p><h3 id="set-红黑树"><a href="#set-红黑树" class="headerlink" title="set 红黑树"></a>set 红黑树</h3><p>set 中存储的元素是唯一的，插入重复元素会被忽略</p><h4 id="multiset-红黑树"><a href="#multiset-红黑树" class="headerlink" title="multiset(红黑树)"></a>multiset(红黑树)</h4><p>含有 Key 类型对象有序集的容器。与 set 不同，它允许多个 Key 拥有等价的值。用关键比较函数 Compare 进行排序。搜索、插入和移除操作拥有对数复杂度。</p><h4 id="unordered-multiset-哈希表"><a href="#unordered-multiset-哈希表" class="headerlink" title="unordered_multiset(哈希表)"></a>unordered_multiset(哈希表)</h4><p>篮子不能太长，如果元素的个数大于等于篮子，篮子就要重新扩充大于等于两倍的元素个数</p><h4 id="unordered-set-哈希表）"><a href="#unordered-set-哈希表）" class="headerlink" title="unordered_set (哈希表）"></a>unordered_set (哈希表）</h4><h3 id="四个容器区别总结"><a href="#四个容器区别总结" class="headerlink" title="四个容器区别总结"></a>四个容器区别总结</h3><p>set 和 multiset 是基于红黑树实现的关联容器，可以快速插入、删除、查找元素，并且元素默认按照元素值从小到大排序，但插入、删除和查找等操作的时间复杂度为 O(log n)。</p><p>unordered_set 和 unordered_multiset 是基于哈希表实现的关联容器，可以快速插入、删除、查找元素，并且插入、删除和查找等操作的时间复杂度为 O(1)，但元素没有固定的顺序。</p><p>在选择使用哪种容器时，需要考虑元素是否需要排序以及对性能的要求。如果元素需要排序，且对性能要求不是非常高，可以选择 set 或 multiset；如果对性能要求比较高，可以选择 unordered_set 或 unordered_multiset。</p><h4 id="四个容器的用法："><a href="#四个容器的用法：" class="headerlink" title="四个容器的用法："></a>四个容器的用法：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//1.定义</span><br><span class="line">std::set&lt;int&gt; s;</span><br><span class="line">std::multiset&lt;int&gt; ms;</span><br><span class="line">std::unordered_multiset&lt;int&gt; ums;</span><br><span class="line">std::unordered_set&lt;int&gt; us;</span><br><span class="line">//2.插入</span><br><span class="line">s.insert(5);</span><br><span class="line">s.insert(2);</span><br><span class="line">ms.insert(3);</span><br><span class="line">ms.insert(4);</span><br><span class="line">/*后面两个容器也一样*/</span><br><span class="line"></span><br><span class="line">//3.查找元素</span><br><span class="line">auto it = s.find(2);//返回的是迭代器指针</span><br><span class="line">std::cout &lt;&lt; *it;</span><br><span class="line">//4.遍历</span><br><span class="line">for (auto it = s.begin(); it != s.end(); ++it) &#123;</span><br><span class="line">std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;; // 输出 set 容器中的元素</span><br><span class="line">&#125;</span><br><span class="line">for (auto it = ms.begin(); it != ms.end(); ++it) &#123;</span><br><span class="line">std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;; // 输出 multiset 容器中的元素</span><br><span class="line">&#125;</span><br><span class="line">for (auto i : ms)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; i&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">for (auto i : s)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; i&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">//5.合并</span><br><span class="line">s.merge(ms);</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>Map是C++ STL中的一个关联式容器，它提供了一种映射关系的数据结构，即一组key-value对，其中key是唯一的，value可以重复。Map中的元素是按照key的大小进行排序的，因此可以进行快速的查找和插入操作。Map支持[]和insert等操作，可以通过迭代器进行遍历。Map的底层实现一般采用红黑树，因此它的插入、删除和查找操作的时间复杂度都是O(log n)。</p><p>用法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*插入，创建，初始化,修改*/</span><br><span class="line">std::map&lt;std::string, int&gt; m&#123; &#123;&quot;CPU&quot;,10&#125; ,&#123;&quot;GPU&quot;,20&#125;&#125;;</span><br><span class="line">m.insert(std::pair&lt;std::string, int&gt;(&quot;ARM&quot;, 35));//插入</span><br><span class="line">m[&quot;ARM&quot;] = 45;</span><br><span class="line">m[&quot;Map&quot;] = 15;//插入新值</span><br><span class="line"></span><br><span class="line">/*遍历方法*/</span><br><span class="line">for (const auto&amp; [key, value] : m)</span><br><span class="line">std::cout &lt;&lt; &#x27;[&#x27; &lt;&lt; key &lt;&lt; &quot;] = &quot; &lt;&lt; value &lt;&lt; &quot;; &quot;;</span><br><span class="line"></span><br><span class="line">for (auto it = m.begin(); it != m.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h3><p>Multimap是一个允许重复键的Map，它也是一个关联式容器，提供了一种映射关系的数据结构，其中一组key-value对中的key可以重复，而value可以不重复。Multimap的元素同样是按照key的大小进行排序的，并且支持[]和insert等操作，可以通过迭代器进行遍历。Multimap的底层实现一般采用红黑树，因此它的插入、删除和查找操作的时间复杂度也都是O(log n)。</p><p>用法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//2.multimap</span><br><span class="line">std::multimap&lt;std::string, int&gt; m;</span><br><span class="line">m.insert(std::pair&lt;std::string, int&gt;(&quot;map&quot;, 10));</span><br><span class="line">m.insert(std::pair&lt;std::string, int&gt;(&quot;map&quot;, 10));</span><br><span class="line">m.insert(std::pair&lt;std::string, int&gt;(&quot;map&quot;, 10));</span><br><span class="line">//m[&quot;map&quot;] = 15;//没有[]操作符 error</span><br><span class="line">for (auto it = m.begin(); it != m.end(); it++) &#123;</span><br><span class="line">std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot; : &quot; &lt;&lt; it-&gt;second &lt;&lt;std:: endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Multimap的用法和Map类似，只是插入操作不会覆盖已有的键值对。</p><h3 id="unordered-multimap"><a href="#unordered-multimap" class="headerlink" title="unordered_multimap"></a>unordered_multimap</h3><p>unordered_multimap是一个允许重复键的unordered_map，它也是一个哈希表，提供了一种映射关系的数据结构，其中一组key-value对中的key可以重复，而value可以不重复。unordered_multimap中的元素是按照哈希值进行存储的，因此查找和插入操作的时间复杂度是O(1)。</p><p>用法：<br>unordered_map的用法和Map类似，只是底层实现不同，插入操作的时间复杂度为O(1)。</p><h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><p>unordered_map是C++ STL中的一个哈希表，它提供了一种映射关系的数据结构，其中一组key-value对中的key是唯一的，而value可以重复。unordered_map中的元素是按照哈希值进行存储的，因此查找和插入操作的时间复杂度是O(1)。</p><p>用法：<br>unordered_multimap的用法和unordered_map类似，只是允许键值对中的键重复。</p><h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><p>Map和Multimap都是基于红黑树实现的，而unordered_map和unordered_multimap都是基于哈希表实现的。因此，Map和Multimap的插入、删除和查找操作的时间复杂度都是O(log n)，而unordered_map和unordered_multimap的插入、删除和查找操作的时间复杂度都是O(1)。另外，Map和Multimap中的元素是按照key的大小进行排序的，而unordered_map和unordered_multimap中的元素是按照哈希值进行存储的，因此它们的遍历顺序可能不同。此外，Multimap和unordered_multimap允许重复键，而Map和unordered_map不允许重复键。</p><h3 id="补充stl算法"><a href="#补充stl算法" class="headerlink" title="补充stl算法"></a>补充stl算法</h3><h4 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound"></a>upper_bound</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; v = &#123;1, 2, 3, 4, 4, 6, 7, 8, 9&#125;;</span><br><span class="line">  auto it = std::upper_bound(v.begin(), v.end(), 4);</span><br><span class="line">  if (it != v.end()) &#123;</span><br><span class="line">      std::cout &lt;&lt; &quot;The first element greater than 4 is: &quot; &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      std::cout &lt;&lt; &quot;No element greater than 4&quot; &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>std::upper_bound将返回一个迭代器，指向第一个大于value的元素。如果不存在这样的元素，std::upper_bound将返回last。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cpp知识补充&quot;&gt;&lt;a href=&quot;#cpp知识补充&quot; class=&quot;headerlink&quot; title=&quot;cpp知识补充&quot;&gt;&lt;/a&gt;cpp知识补充&lt;/h1&gt;&lt;p&gt;01 - 侯捷 - C++面向对象高级开发（上下两部曲）&lt;/p&gt;
&lt;p&gt;02 - 侯捷 - STL标</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>GDB调试</title>
    <link href="https://null0x0f.github.io/posts/46594b90.html"/>
    <id>https://null0x0f.github.io/posts/46594b90.html</id>
    <published>2023-04-15T11:31:20.000Z</published>
    <updated>2023-05-05T06:14:03.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h1><h2 id="编译c程序"><a href="#编译c程序" class="headerlink" title="编译c程序"></a>编译c程序</h2><p>gcc test.c -o test.out</p><h2 id="生成debug-info文件"><a href="#生成debug-info文件" class="headerlink" title="生成debug info文件"></a>生成debug info文件</h2><p>gcc -g test.c -o test.out</p><h2 id="打断点"><a href="#打断点" class="headerlink" title="打断点"></a>打断点</h2><p>b main<br>b path :行数<br>r<br>n 不进函数体单个执行<br>s  进函数单个执行</p><h2 id="看断点"><a href="#看断点" class="headerlink" title="看断点"></a>看断点</h2><p>info b 看断点<br>d 行数  删除断点<br>c continue</p><p>bt 看函数调用栈</p><h2 id="监视"><a href="#监视" class="headerlink" title="监视"></a>监视</h2><p>watch 变量</p><p>info r 看寄存器的值</p><h2 id="查看代码或汇编"><a href="#查看代码或汇编" class="headerlink" title="查看代码或汇编"></a>查看代码或汇编</h2><p>layout src  查看代码<br>layout asm 查看汇编 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GDB调试&quot;&gt;&lt;a href=&quot;#GDB调试&quot; class=&quot;headerlink&quot; title=&quot;GDB调试&quot;&gt;&lt;/a&gt;GDB调试&lt;/h1&gt;&lt;h2 id=&quot;编译c程序&quot;&gt;&lt;a href=&quot;#编译c程序&quot; class=&quot;headerlink&quot; title=&quot;编译c</summary>
      
    
    
    
    
  </entry>
  
</feed>
