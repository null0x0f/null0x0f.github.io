<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>c plus plus | NULL'blog</title><meta name="author" content="NULL+"><meta name="copyright" content="NULL+"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="cpp知识补充01 - 侯捷 - C++面向对象高级开发（上下两部曲） 02 - 侯捷 - STL标准库和泛型编程 03 - 侯捷 - C++设计模式 04 - 侯捷 - C++新标准C++11&amp;14 05 - 侯捷 - C++内存管理机制 06 - 侯捷 C++ Startup 揭密：C++ 程序的生前和死后 07、算法原理与实践（选修） 08、系统设计与实践（选修） 书籍:c++ pr"><meta property="og:type" content="article"><meta property="og:title" content="c plus plus"><meta property="og:url" content="https://null0x0f.github.io/posts/d99aa42e.html"><meta property="og:site_name" content="NULL&#39;blog"><meta property="og:description" content="cpp知识补充01 - 侯捷 - C++面向对象高级开发（上下两部曲） 02 - 侯捷 - STL标准库和泛型编程 03 - 侯捷 - C++设计模式 04 - 侯捷 - C++新标准C++11&amp;14 05 - 侯捷 - C++内存管理机制 06 - 侯捷 C++ Startup 揭密：C++ 程序的生前和死后 07、算法原理与实践（选修） 08、系统设计与实践（选修） 书籍:c++ pr"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><meta property="article:published_time" content="2023-04-24T11:22:45.000Z"><meta property="article:modified_time" content="2024-09-20T07:29:47.156Z"><meta property="article:author" content="NULL+"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://null0x0f.github.io/posts/d99aa42e.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="manifest" href="/manifest.json"><meta name="msapplication-TileColor" content="#3b70fc"><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/code.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/%E6%89%8B%E6%9C%BA%E6%95%B0%E6%8D%AE.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/%E6%99%BA%E8%83%BD%E6%89%8B%E6%9C%BA.png"><link rel="mask-icon" href="/img/siteicon/%E6%95%B0%E6%8D%AE%E9%A9%BE%E9%A9%B6%E8%88%B1.png" color="#5bbad5"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
     homepage: theme.post_meta.page ? (theme.post_meta.page.date_format === 'relative') : false,
     post: theme.post_meta.post ? (theme.post_meta.post.date_format === 'relative') : false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"c plus plus",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-09-20 07:29:47"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.6/lib/clock.min.css"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload='this.media="all"'><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload='this.media="screen"'><link rel="stylesheet" href="https://cdn.cbd.int/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload='this.media="all"'><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="NULL'blog" type="application/atom+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="NULL'blog"><span class="site-name">NULL'blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">c plus plus</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-24T11:22:45.000Z" title="发表于 2023-04-24 11:22:45">2023-04-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-20T07:29:47.156Z" title="更新于 2024-09-20 07:29:47">2024-09-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="c plus plus"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="cpp知识补充"><a href="#cpp知识补充" class="headerlink" title="cpp知识补充"></a>cpp知识补充</h1><p>01 - 侯捷 - C++面向对象高级开发（上下两部曲）</p><p>02 - 侯捷 - STL标准库和泛型编程</p><p>03 - 侯捷 - C++设计模式</p><p>04 - 侯捷 - C++新标准C++11&amp;14</p><p>05 - 侯捷 - C++内存管理机制</p><p>06 - 侯捷 C++ Startup 揭密：C++ 程序的生前和死后</p><p>07、算法原理与实践（选修）</p><p>08、系统设计与实践（选修）</p><p>书籍:c++ primer<br>effective modern c++<br>stl源码剖析</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>拿来当c++知识点补充库，顺序不是按照学习的顺序，是感觉哪个不会了，看书或视频补充知识点。</p><h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><p>定义命名空间<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//如果不引入 using namespace std;就需要我们显示引入,例如std::cout</span><br><span class="line">namespace a</span><br><span class="line">&#123;</span><br><span class="line">  int a = 10;</span><br><span class="line">&#125;</span><br><span class="line">namespace b</span><br><span class="line">&#123;</span><br><span class="line">int a = 20;</span><br><span class="line">namespace c</span><br><span class="line">&#123;</span><br><span class="line">  int a = 30;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>使用命名空间<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  using namespace a;</span><br><span class="line">	using namespace b;</span><br><span class="line">	cout &lt;&lt; a::a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; b::a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; b::c::a &lt;&lt; endl;</span><br><span class="line">	using b::c::a;</span><br><span class="line">	cout &lt;&lt; a;</span><br><span class="line">  </span><br><span class="line">  system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>不使用using namespace std 原因：<br>如果没有命名空间，这些变量、函数、类的名称将都存在于全局命名空间中，当定义了一个函数名与标准库中函数名相同时，就会发生冲突。<br>比如，我们在自己的程序中定义了一个Stack类，而我们程序中使用的某个库中也可能定义了一个同名的类，此时名称就冲突了。</p><h2 id="顶层const和底层const"><a href="#顶层const和底层const" class="headerlink" title="顶层const和底层const"></a>顶层const和底层const</h2><p>const修饰的变量不可以改变就是顶层const：<br>const int a = 10;<br>底层const：<br>const int &amp;ra = 10;</p><p>c++ primer :当执行对象的拷贝操作时，常量的顶层const不受什么影响，而底层const必须一致</p><p>const引用理解:<br>1.引用不是对象且不进行拷贝<br>2.常量引用如果在左侧，右侧可以接任何东西<br>3.非常量引用 = 常量 error<br>4.引用如果在等号右侧请忽略引用<br>5.非常量 = 常引用</p><p>判断方法:<br><img src="/source/img/const1.png" alt="const1"><br><img src="/source/img/const2.png" alt="const2"></p><p>代码详解:<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	int i = 0;</span><br><span class="line">	const int p = 10;//顶层const(不能被修改)</span><br><span class="line">	const int* p1 = &amp;p;</span><br><span class="line">	p1 = &amp;i;</span><br><span class="line">//底层const 允许修改p1的值   const 修饰的是int 不能改变的是 *p1  int *p1是个指针，地址没变，里面值改变无所谓   const修饰的是什么,p1就指向的是什么 *p就相当于（const int）*p</span><br><span class="line">    int* const p2 =&amp;i;//顶层const p2的值不允许被修改 p2是个指针，里面存放的是地址，地址是不可以改变的，值是可以改变的。  const  int*p2  然后你可以通过改变p2指向这个内存地址里的值,来改变p2读出来的值</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>const int* p1 = &p;<p></p><p>p1是一个指向const int类型的指针变量。<br>&amp;p是一个指向int类型变量p的地址。<br>通过将&amp;p赋值给p1，p1成为了一个指向p的const int类型的指针。<br>这意味着p1指向的int类型的数据是只读的，不能通过p1来修改。<br>int* const p2 = &i;</p><p>p2是一个指向int类型的常量指针变量。<br>&amp;i是一个指向int类型变量i的地址。<br>通过将&amp;i赋值给p2，p2成为了一个指向i的int类型的常量指针。<br>这意味着p2指向的int类型数据可以修改，但是p2本身的指向是不可变的，即p2不能指向其他的地址。</p><h2 id="register-加强"><a href="#register-加强" class="headerlink" title="register 加强"></a>register 加强</h2><p>register 关键字请求编译器将局部变量存储于寄存器中。<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">  std::cout&lt;&lt;&amp;a&lt;&lt;endl;</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="引用剖析"><a href="#引用剖析" class="headerlink" title="引用剖析"></a>引用剖析</h2><h3 id="引用语法"><a href="#引用语法" class="headerlink" title="引用语法"></a>引用语法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">   <span class="type">int</span> &amp;b = a;<span class="comment">//b就是a的别名 int *const b = &amp;a</span></span><br><span class="line">   b= <span class="number">11</span>;<span class="comment">//*b = 11</span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用本质"><a href="#引用本质" class="headerlink" title="引用本质"></a>引用本质</h3><p>引用在c++内部实现是一个常量指针<br>Type&amp; name&lt;——&gt;Type * const name</p><h3 id="函数返回值是引用"><a href="#函数返回值是引用" class="headerlink" title="函数返回值是引用"></a>函数返回值是引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> *<span class="title">get_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回的是本身的一个副本(20)</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">get_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="type">int</span> a2 = <span class="built_in">get_2</span>();<span class="comment">//20</span></span><br><span class="line">   <span class="type">int</span> &amp;a3 = <span class="built_in">get_2</span>();<span class="comment">//返回的是a的本身 地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若返回静态变量或全局变量<br>可以成为其他引用初始值<br>既可以作为右值使用，也可以作为左值使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">g1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">g2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">  a++;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">g1</span>() =<span class="number">100</span>;<span class="comment">//error </span></span><br><span class="line">   <span class="built_in">g2</span>() = <span class="number">100</span>;<span class="comment">//返回的是变量本身 g2()返回的a当左值使用 </span></span><br><span class="line">   <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h2><p>用来代替宏代码片段<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> inline void fun() </span><br><span class="line">&#123;</span><br><span class="line">   int a = 10;</span><br><span class="line">   cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> #define Myfunc(a,b)((a)&lt;(b)？(a):(b))</span><br><span class="line"> inline int myfunc(int a,int b) </span><br><span class="line">&#123;</span><br><span class="line">   return a&lt;b?a:b</span><br><span class="line">&#125;</span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line"> int c1 = myfunc(++a,b)//a=2 b = 3 c =2</span><br><span class="line"> int c2 = Myfunc(++a,b)//==&gt;宏展开((++a)&lt;(b)?(++a):(b))</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>内联不能做声明，必须和函数体实现写在一块<br>adsd<p></p><h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>构造函数：完成对属性的初始化工作（先创建的对象先构造）<br>析构函数：先创建的对象后释放（栈机制）</p><h3 id="构造函数分类"><a href="#构造函数分类" class="headerlink" title="构造函数分类"></a>构造函数分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class test</span><br><span class="line">&#123;</span><br><span class="line">  private:</span><br><span class="line">  int a,b,c,d;</span><br><span class="line">  public:</span><br><span class="line">  test()//无参构造</span><br><span class="line">  &#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  test(int a,int b)//有参构造</span><br><span class="line">  &#123;</span><br><span class="line">     this-&gt;a = a;</span><br><span class="line">     this-&gt;b = b;</span><br><span class="line">  &#125;</span><br><span class="line">  test(const test&amp; obj)//赋值构造函数</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">   test t2//无参构造</span><br><span class="line">   test t(2,4);//有参调用</span><br><span class="line">   test t1(t);//拷贝构造</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深拷贝和浅拷贝问题"><a href="#深拷贝和浅拷贝问题" class="headerlink" title="深拷贝和浅拷贝问题"></a>深拷贝和浅拷贝问题</h3><h4 id="浅拷贝分析"><a href="#浅拷贝分析" class="headerlink" title="浅拷贝分析"></a>浅拷贝分析</h4><p>默认的拷贝构造函数，编译器提供<br>把对象1的属性拷贝给对象二<br>把指针变量的值拷贝给对象二，并没有把指针变量所指向的内存空间的数据拷贝过来<br>两个指针变量指向同一个空间</p><p>obj2析构函数 把指向的内存空间析构<br>obj2 指向null，obj1仍然指向堆里被释放的内存空间。<br>obj1再析构，还是析构的obj2之前析构的那一块空间，，结果析构两次，造成空间的coredump</p><p>coredump出现原因:<br><img src="/source/img/coredump.png" alt="coredump"></p><h4 id="等号操作也是浅拷贝操作"><a href="#等号操作也是浅拷贝操作" class="headerlink" title="等号操作也是浅拷贝操作"></a>等号操作也是浅拷贝操作</h4><h2 id="临时对象"><a href="#临时对象" class="headerlink" title="临时对象"></a>临时对象</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>构造之后马上析构</p><h3 id="构造函数中调用构造函数"><a href="#构造函数中调用构造函数" class="headerlink" title="构造函数中调用构造函数"></a>构造函数中调用构造函数</h3><p>危险行为</p><h2 id="new-和delete"><a href="#new-和delete" class="headerlink" title="new 和delete"></a>new 和delete</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int *arr = new int[10];</span><br><span class="line">delete []arr;</span><br><span class="line"></span><br><span class="line">//动态分配对象</span><br><span class="line">object *pt = new object;</span><br><span class="line">delete pt;</span><br></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="友元函数和友元类"><a href="#友元函数和友元类" class="headerlink" title="友元函数和友元类"></a>友元函数和友元类</h3><h4 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	friend void modify(A* pa,int _a);</span><br><span class="line">	A(int a, int b)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;a = a;</span><br><span class="line">		this-&gt;b = b;</span><br><span class="line">	&#125;</span><br><span class="line">	void geta()</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;this-&gt;a;</span><br><span class="line">	&#125;</span><br><span class="line">	//声明位置和public和private没关系</span><br><span class="line">private:</span><br><span class="line">	int a;</span><br><span class="line">	int b;</span><br><span class="line">&#125;;</span><br><span class="line">void modify(A* pa,int _a)</span><br><span class="line">&#123;</span><br><span class="line">	pa-&gt;a = _a;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	A a(5, 3);</span><br><span class="line">	modify(&amp;a, 100);</span><br><span class="line">	a.geta();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h4><h4 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h4><p>这两个都写在vs里了<br><img src="/source/img/%E9%87%8D%E8%BD%BD.png" alt="重载"></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h3 id="访问父类的语法和概念"><a href="#访问父类的语法和概念" class="headerlink" title="访问父类的语法和概念"></a>访问父类的语法和概念</h3><h3 id="派生类的访问控制"><a href="#派生类的访问控制" class="headerlink" title="派生类的访问控制"></a>派生类的访问控制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">类的单个类访问控制</span><br><span class="line">//public 修饰地成员变量方法在类的内部 类的外部都能使用</span><br><span class="line">//protected 修饰的成员变量方法，在类的内部使用，在继承的子类中可用</span><br><span class="line">//private 修饰地成员变量方法只能在类的内部使用 类的外部不行</span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">  int a;</span><br><span class="line">  void printT()</span><br><span class="line">  &#123;</span><br><span class="line">  cout&lt;&lt;&quot;printT&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  protected:</span><br><span class="line">  int b;</span><br><span class="line">  private:</span><br><span class="line">  int c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class test:public Test</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">   void user()</span><br><span class="line">   &#123;</span><br><span class="line">     a = 0;//ok</span><br><span class="line">     b= 0;//ok </span><br><span class="line">     c = 0;//error 私有变量</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/source/img/%E6%B4%BE%E7%94%9F%E7%B1%BB%E8%AE%BF%E9%97%AE.png" alt="派生类访问"><br>protect 关键字修饰变量使用，是为了继承</p><h3 id="继承中构造和析构"><a href="#继承中构造和析构" class="headerlink" title="继承中构造和析构"></a>继承中构造和析构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//赋值兼容性原则</span><br><span class="line">//1.基类指针(引用)指向子类对象 可以调用父类方法</span><br><span class="line">class Parent</span><br><span class="line">&#123;</span><br><span class="line">  private:</span><br><span class="line">  int a;</span><br><span class="line">  int b;</span><br><span class="line">  public:</span><br><span class="line">  Parent(int a1,int b1):a(a1),b(b1)&#123;&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">class child</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">int c;</span><br><span class="line">public:</span><br><span class="line">child(int a,int b,int c1):parent(a,b),c(c1)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/source/img/%E7%BB%A7%E6%89%BF1.png" alt="继承1"><br><img src="/source/img/%E7%BB%A7%E6%89%BF2.png" alt="继承2"></p><h3 id="继承和虚函数"><a href="#继承和虚函数" class="headerlink" title="继承和虚函数"></a>继承和虚函数</h3><p>virtual函数:你希望derived class 重新定义它，且你对他已有默认定义<br>pure virtual 函数:erived class 重新定义它，且你对他没有默认定义</p><h3 id="复合和继承"><a href="#复合和继承" class="headerlink" title="复合和继承"></a>复合和继承</h3><h3 id="委托和继承"><a href="#委托和继承" class="headerlink" title="委托和继承"></a>委托和继承<img src="delegation.png" alt="delegation"></h3><p><img src="/source/img/%E5%A7%94%E6%89%982.png" alt="委托2"></p><h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class person//抽象基类(类似于接口)</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">	string name;</span><br><span class="line">	int height;</span><br><span class="line">	int age;</span><br><span class="line">public:</span><br><span class="line">	virtual void getinfo() const = 0;//纯虚函数</span><br><span class="line">	virtual void action() = 0;</span><br><span class="line">	string getname()</span><br><span class="line">	&#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line">	person(string&amp; s, int h,int a) :name(s), height(h),age(a) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class dancer :public person</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	string danceaction;</span><br><span class="line">public:</span><br><span class="line">	dancer(string na,int h, int a, string ac) :person(na,h,a)</span><br><span class="line">	&#123;</span><br><span class="line">		danceaction = ac;</span><br><span class="line">	&#125;</span><br><span class="line">	void getinfo() const</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;name:&quot; &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;height:&quot; &lt;&lt; height &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;age:&quot; &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;danceaction:&quot; &lt;&lt;danceaction&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void action()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;dance&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。<br>因此，如果一个 ABC 的子类需要被实例化，则必须实现每个纯虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。<br>可用于实例化对象的类被称为具体类。<a target="_blank" rel="noopener" href="https://www.runoob.com/cplusplus/cpp-interfaces.html">https://www.runoob.com/cplusplus/cpp-interfaces.html</a></p><h3 id="继承的动态内存分配"><a href="#继承的动态内存分配" class="headerlink" title="继承的动态内存分配"></a>继承的动态内存分配</h3><p>基类使用动态内存分配，派生类不使用动态内存分配。<br>可以省略构造函数和析构函数中的内存分配和释放操作，直接继承基类中的构造和析构函数。<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">    Base(const char* str) &#123;</span><br><span class="line">        data_ = new char[strlen(str) + 1];</span><br><span class="line">        strcpy(data_, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual ~Base() &#123;</span><br><span class="line">        delete[] data_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const char* getData() const &#123;</span><br><span class="line">        return data_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    char* data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 派生类，不使用动态内存分配</span><br><span class="line">class Derived : public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    Derived(const char* str, int value)</span><br><span class="line">        : Base(str), value_(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    int getValue() const &#123;</span><br><span class="line">        return value_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int value_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>基类使用动态内存分配，派生类也使用动态内存分配<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class BASE</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	char* base;</span><br><span class="line">public:</span><br><span class="line">	BASE(const char *str)</span><br><span class="line">	&#123;</span><br><span class="line">		base = new char[strlen(str) + 1];</span><br><span class="line">		strcpy(base, str);</span><br><span class="line">	&#125;</span><br><span class="line">	virtual ~BASE()</span><br><span class="line">	&#123;</span><br><span class="line">		delete[]base;</span><br><span class="line">	&#125;</span><br><span class="line">	BASE&amp; operator=(const BASE&amp; str)</span><br><span class="line">	&#123;</span><br><span class="line">		if (this == &amp;str)</span><br><span class="line">		&#123;</span><br><span class="line">			return *this;</span><br><span class="line">		&#125;</span><br><span class="line">		delete[]base;</span><br><span class="line">		base = new char[strlen(str.base) + 1];</span><br><span class="line">		strcpy(base,str.base);</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class derived :public BASE</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	char* dervived;</span><br><span class="line">public:</span><br><span class="line">	derived(const char* str):BASE(str)</span><br><span class="line">	&#123;</span><br><span class="line">		dervived = new char[strlen(str) + 1];</span><br><span class="line">		strcpy(dervived, str);</span><br><span class="line">	&#125;</span><br><span class="line">	derived&amp; operator=(const derived&amp; str)</span><br><span class="line">	&#123;</span><br><span class="line">		if (this == &amp;str)</span><br><span class="line">		&#123;</span><br><span class="line">			return *this;</span><br><span class="line">		&#125;</span><br><span class="line">		delete[]dervived;</span><br><span class="line">		BASE::operator=(str);</span><br><span class="line">		dervived = new char[strlen(str.dervived) + 1];</span><br><span class="line">		strcpy(dervived, str.dervived);</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	~derived()</span><br><span class="line">	&#123;</span><br><span class="line">	delete[] dervived;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><h2 id="conversion-function"><a href="#conversion-function" class="headerlink" title="conversion function"></a>conversion function</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">fraction</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> numrator;</span><br><span class="line">	<span class="type">int</span> denominator;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">fraction</span>(<span class="type">int</span> num, <span class="type">int</span> den = <span class="number">1</span>) :<span class="built_in">numrator</span>(num), <span class="built_in">denominator</span>(den) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">double</span>(numrator * <span class="number">1.0</span> / denominator);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">	<span class="type">double</span> d = f + <span class="number">4</span>;</span><br><span class="line">	cout &lt;&lt; d;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>double d = 4 + f;这一语句会首先查找Fraction是否有重载操作符 operator + (double, Fraction) 的函数，由于没有，所以调用会转换函数operator double() const。</p><p>另外，转换函数除了可以将一个类型转换成另一个基本类型，还可以将一个类型转换成另一个复合类型（例如string类型）。</p><h4 id="non-explicit-one-argument-ctor"><a href="#non-explicit-one-argument-ctor" class="headerlink" title="non -explicit-one-argument ctor"></a>non -explicit-one-argument ctor</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Fraction </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Fraction(int num, int den=1) :</span><br><span class="line">        m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Fraction operator + (const Fraction&amp; f) &#123;</span><br><span class="line">        return Fraction(...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int m_numerator;  // 分子</span><br><span class="line">    int m_denominator;  // 分母</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Fraction f(3, 5);</span><br><span class="line">Fraction d2 = f + 4; </span><br></pre></td></tr></table></figure><p>只要一个实参就够了，也可以传两个实参。将别的东西转换成这个类对象</p><h4 id="conversion-function-vs-non-explicit-one-argument-constructor"><a href="#conversion-function-vs-non-explicit-one-argument-constructor" class="headerlink" title="conversion function vs. non-explicit-one-argument constructor"></a>conversion function vs. non-explicit-one-argument constructor</h4><h4 id="explicit-one-argument-constructor"><a href="#explicit-one-argument-constructor" class="headerlink" title="explicit-one-argument constructor"></a>explicit-one-argument constructor</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Fraction </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    explicit Fraction(int num, int den=1) :</span><br><span class="line">        m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    operator double() const &#123;</span><br><span class="line">        return (double) (m_numerator / m_denominator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Fraction operator + (const Fraction&amp; f) &#123;</span><br><span class="line">        return Fraction(...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int m_numerator;  // 分子</span><br><span class="line">    int m_denominator;  // 分母</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Fraction f(3, 5);</span><br><span class="line">Fraction d2 = f + 4;  // [Error] convertion from double to Fraction requested</span><br></pre></td></tr></table></figure><p>由于在构造函数前面增加了explicit关键字，所以不能将4转换成Fraction类型；也不能先将f转换成double类型，与4相加后再将double转换成Fraction。</p><h2 id="pointer-like-classes"><a href="#pointer-like-classes" class="headerlink" title="pointer like classes"></a>pointer like classes</h2><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>智能指针是你在堆栈上声明的类模板，并可通过使用指向某个堆分配的对象的原始指针进行初始化。 在初始化智能指针后，它将拥有原始的指针。 这意味着智能指针负责删除原始指针指定的内存。 智能指针析构函数包括要删除的调用，并且由于在堆栈上声明了智能指针，当智能指针超出范围时将调用其析构函数，尽管堆栈上的某处将进一步引发异常。</p><p>C++ 中有三种常用的智能指针：</p><ol><li><p>unique_ptr：独占所有权的智能指针，不能被复制，只能被移动。当 unique_ptr 超出作用域时，它所指向的对象会被自动释放。</p></li><li><p>shared_ptr：共享所有权的智能指针，可以被多个 shared_ptr 共享。当最后一个 shared_ptr 超出作用域时，它所指向的对象会被自动释放。</p></li><li><p>weak_ptr：弱引用的智能指针，不能直接访问所指向的对象，必须通过 lock() 函数获得一个 shared_ptr 才能访问。weak_ptr 不会增加所指对象的引用计数，因此不会影响所指对象的生命周期。</p></li></ol><h4 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h4><p>用法：<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;memory&gt;</span><br><span class="line">shared_ptr&lt;double&gt; p1(new double(42));</span><br><span class="line">shared_ptr&lt;int&gt;p2= make_shared&lt;int&gt;(42);</span><br></pre></td></tr></table></figure><br>拷贝和赋值<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">auto r = make_shared&lt;int&gt;(42);//r指向int只有一个引用</span><br><span class="line">r=q;//给r赋值</span><br><span class="line">    //q指向的对象引用次数++</span><br><span class="line">    //r指向对象引用次数--</span><br><span class="line">    //r没有引用了，就会自动释放</span><br></pre></td></tr></table></figure><br>离开作用域，它指向内存也会自动释放<br>但是如果有其他智能指针也指向这块内存，他就不会被释放<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void use_factory(T arg)</span><br><span class="line">&#123;</span><br><span class="line">   shared_ptr&lt;Foo&gt; p = factory(arg);</span><br><span class="line">   return p;//引用计数增加</span><br><span class="line">&#125;//离开作用域但不会被释放</span><br></pre></td></tr></table></figure><p></p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><h2 id="fuction-like-classes"><a href="#fuction-like-classes" class="headerlink" title="fuction like classes"></a>fuction like classes</h2><h3><a href="#" class="headerlink"></a></h3><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><h3 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h3><p><img src="/source/img/%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF.png" alt="成员模板.png"></p><h3 id="模板特化"><a href="#模板特化" class="headerlink" title="模板特化"></a>模板特化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">template&lt;&gt;</span><br><span class="line">struct hash&lt;char&gt;</span><br><span class="line">&#123;</span><br><span class="line"> size_t operator()(char x) const</span><br><span class="line">&#123;</span><br><span class="line">   return x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;&gt;</span><br><span class="line">struct hash&lt;int&gt;</span><br><span class="line">&#123;</span><br><span class="line"> size_t operator()(int x) const</span><br><span class="line">&#123;</span><br><span class="line">   return x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;&gt;</span><br><span class="line">struct hash&lt;long&gt;</span><br><span class="line">&#123;</span><br><span class="line"> size_t operator()(long x) const</span><br><span class="line">&#123;</span><br><span class="line">   return x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="偏特化-局部特化"><a href="#偏特化-局部特化" class="headerlink" title="偏特化(局部特化)"></a>偏特化(局部特化)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T,class alloc&gt;</span><br><span class="line"> class name</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class alloc&gt;</span><br><span class="line">class name&lt;bool, alloc&gt; </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>范围的偏<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">c</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">c</span>&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>如果使用者使用的是指针就用第二个模板<br>如果不是指针，用的是第一个模板<p></p><h3 id="模板模板参数"><a href="#模板模板参数" class="headerlink" title="模板模板参数"></a>模板模板参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T,template&lt;class T&gt; class smartptr&gt;</span><br><span class="line"></span><br><span class="line">//第一个参数是 T类型 ，第二个参数是一个smartptr，它可以指定一个T类型变量</span><br><span class="line">class XCls</span><br><span class="line">&#123;</span><br><span class="line"> private:</span><br><span class="line"> smartptr&lt;T&gt; sp;</span><br><span class="line"> public:</span><br><span class="line"> XCls():sp(new T)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">XCls&lt;string,shared_ptr&gt; p1;</span><br></pre></td></tr></table></figure><h2 id="三个主题"><a href="#三个主题" class="headerlink" title="三个主题"></a>三个主题</h2><h3 id="pack"><a href="#pack" class="headerlink" title="pack"></a>pack</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T,typename...Types&gt;</span><br><span class="line">void print(const T&amp;firstArg,const Type&amp;...args)</span><br><span class="line">&#123;</span><br><span class="line">   cout&lt;&lt;firstArg&lt;&lt;endl;</span><br><span class="line">   print(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用sizeof…(args)可以知道包有多少</p><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>auto声明变量必须要赋值</p><h3 id="ranged-base-for"><a href="#ranged-base-for" class="headerlink" title="ranged-base for"></a>ranged-base for</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;double&gt; vec;</span><br><span class="line">for(auto elem:vec)</span><br><span class="line">&#123;</span><br><span class="line">  cout&lt;&lt;elem&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(auto&amp; elem:vec)</span><br><span class="line">&#123;</span><br><span class="line">  elem*=3;</span><br><span class="line">&#125;//改变原来vec里的值</span><br></pre></td></tr></table></figure><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int x = 0;</span><br><span class="line">int* p = &amp;x;</span><br><span class="line">int&amp; r =x;//r代表x,r不能代表其他的了</span><br><span class="line">int x2 = 5;</span><br><span class="line">r = x2;//r不能代表x，现在r,x都是5</span><br><span class="line">int&amp; r2 =r;</span><br></pre></td></tr></table></figure><p>reference一定要有初值，只能代表一个，不能代表其他</p><p>32位电脑指针占四个字节</p><p>参数传递</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h2 id="重载new-delete"><a href="#重载new-delete" class="headerlink" title="重载new(),delete()"></a>重载new(),delete()</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line"> void* operator new(std::size_t size)</span><br><span class="line"> &#123;</span><br><span class="line">  std::cout &lt;&lt; &quot;operator new&quot; &lt;&lt; std::endl;</span><br><span class="line">  return std::malloc(size);</span><br><span class="line"> &#125;</span><br><span class="line"> void operator delete(void* ptr)</span><br><span class="line">&#123;</span><br><span class="line"> std::cout &lt;&lt; &quot;operator delete&quot; &lt;&lt; std::endl;</span><br><span class="line"> std::free(ptr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> Foo* m = new Foo;</span><br><span class="line"> std::cout &lt;&lt; sizeof(m) &lt;&lt; std::endl;</span><br><span class="line"> delete m;</span><br><span class="line"> return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类中的operator new默认就是static。所以加static可以，不加也是全局，可以正常使用。</p><p>这种重载的意义是和重载operator new配套。只有operator new报异常了，就会调用对应的operator delete。若没有对应的operator delete，则无法释放内存。</p><h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><p>学习网址：zh.cppreference.com</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>相比于普通数组，array容器访问速度快，安全性高，在传递方式方面，普通数组作为函数参数时，实际上是传递一个指向数组首元素的指针。而array容器作为函数参数时，实际上传递的是整个array容器的值。<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">td::array&lt;int, 5&gt; myarr;</span><br><span class="line">	std::array&lt;int, 5&gt; a2;</span><br><span class="line">	for (int i =0;i&lt;myarr.size();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cin &gt;&gt; myarr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	for (auto it = myarr.begin(); it != myarr.end(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; &quot;\n&quot;;</span><br><span class="line">	std::sort(myarr.begin(),myarr.end());//算法库</span><br><span class="line">	std::ostream_iterator&lt;int&gt; output(std::cout,&quot; &quot;);</span><br><span class="line">	std::reverse_copy(myarr.begin(), myarr.end(), a2.begin());</span><br><span class="line">	std::reverse_copy(myarr.begin(), myarr.end(), output);</span><br><span class="line">	std::array&lt;std::string, 5&gt; a3 = &#123; &quot;aefea&quot;,std::string(&quot;a&quot;) &#125;;</span><br><span class="line">	for (auto&amp; s : a3)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; s &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><br>上述代码中，sort是algorithm库中函数，能将容器内元素从大到小排序，reversecopy函数详见cppconference<p></p><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>能动态调整大小，存储相同类型元素<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; vec;</span><br><span class="line">	std::vector&lt;int&gt; vec2(5);</span><br><span class="line">	std::vector&lt;int&gt; vec3(5, 42);</span><br><span class="line">	std::vector&lt;int&gt; vec4(vec3);</span><br><span class="line">	vec.push_back(10);</span><br><span class="line">	vec.push_back(20);</span><br><span class="line">	//vec.pop_back();//删除末尾元素</span><br><span class="line">	int first = vec[0]; // 使用数组下标访问元素</span><br><span class="line">	int second = vec.at(1); // 使用at()方法访问元素，会检查下标是否越界</span><br><span class="line">	//获取容量</span><br><span class="line">	size_t size = vec.size();//获取向量大小</span><br><span class="line">	size_t capacity = vec.capacity();//分配内存空间大小</span><br><span class="line">	//迭代访问</span><br><span class="line">	for (auto i : vec)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; i&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	for (auto it = vec.begin(); it != vec.end(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><br>data()返回值 : 指向底层元素存储的指针。对于非空容器，返回的指针与首元素地址比较相等。<br>例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void span_func(std::span&lt;const int&gt; data) // C++20 起</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;data = &quot;;</span><br><span class="line">    for (const int e : data)</span><br><span class="line">        std::cout &lt;&lt; e &lt;&lt; &#x27; &#x27;;</span><br><span class="line">    std::cout &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">std::span&lt;int&gt; s&#123;container.data(),container.size() &#125;;</span><br><span class="line">span_func(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注：span 是c++20新特性<p></p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>双向链表<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::list&lt;int&gt; l = &#123;7,5,16,8&#125;;</span><br><span class="line">	l.push_back(25);//添加末尾</span><br><span class="line">	l.push_front(15);//   开头</span><br><span class="line">	std::list&lt;int&gt;::iterator it = std::find(l.begin(),l.end(),16);//用迭代器找到16的位置</span><br><span class="line">	if(it!=l.end())</span><br><span class="line">	l.insert(it, 42);</span><br><span class="line">	std::cout &lt;&lt; *it&lt;&lt;&quot;\n&quot;;</span><br><span class="line">	//迭代打印</span><br><span class="line">	for (auto i : l)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><br>还有pop_back等用法在笔记中不一 一实例了，cppconference中有实例。<p></p><p>list 的原理：</p><p>list 是通过双向链表实现的，每个节点都包含了指向前一个节点和后一个节点的指针。因此，插入和删除元素时只需要修改相关节点的指针即可，不需要像数组那样进行元素的移动。</p><p>由于 list 中的元素是通过指针进行连接的，因此在访问 list 中的元素时，需要通过迭代器来进行访问。迭代器是指向 list 中元素的指针，支持 ++ 操作来遍历 list 中的元素</p><h4 id="forward-list"><a href="#forward-list" class="headerlink" title="forward list"></a>forward list</h4><p>单向列表（单链表）<br>只能从一端进入和移除，所以只能从容器起始插入和删除</p><h3 id="queue-容器的适配器"><a href="#queue-容器的适配器" class="headerlink" title="queue(容器的适配器 )"></a>queue(容器的适配器 )</h3><p>队列<br>queue是一个单口进出的数据结构，没有迭代器<br>first in first out</p><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>双端队列<br>可以两边扩充</p><p>在 C++ STL 中，deque（双端队列）是一种常用的容器，它可以在两端进行插入和删除操作，并且支持随机访问。deque 内部使用一个动态数组来存储元素，可以动态调整大小以适应元素的添加和删除，同时还可以在数组的两端进行快速插入和删除操作，因此可以高效地实现队列和栈等数据结构。</p><p>简单用法例子：<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::deque&lt;int&gt; de(10);</span><br><span class="line">	/*de.push_back(5);</span><br><span class="line">	de.push_front(10);*/</span><br><span class="line">	std::deque&lt;int&gt;::iterator it = de.begin();</span><br><span class="line">	for (it; it != de.end(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		int x = 0;</span><br><span class="line">		std::cin &gt;&gt; x;</span><br><span class="line">		*it = x;</span><br><span class="line">	&#125;</span><br><span class="line">	for (auto i : de)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; i;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="stack-容器的适配器"><a href="#stack-容器的适配器" class="headerlink" title="stack(容器的适配器)"></a>stack(容器的适配器)</h3><p>栈和队列都是不能直接通过构造函数分配元素数量的，必须通过封装vector来实现<br>具体例子：<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; v(10, 0);</span><br><span class="line"> std::stack&lt;int&gt; s(v);</span><br></pre></td></tr></table></figure><p></p><h3 id="set-红黑树"><a href="#set-红黑树" class="headerlink" title="set 红黑树"></a>set 红黑树</h3><p>set 中存储的元素是唯一的，插入重复元素会被忽略</p><h4 id="multiset-红黑树"><a href="#multiset-红黑树" class="headerlink" title="multiset(红黑树)"></a>multiset(红黑树)</h4><p>含有 Key 类型对象有序集的容器。与 set 不同，它允许多个 Key 拥有等价的值。用关键比较函数 Compare 进行排序。搜索、插入和移除操作拥有对数复杂度。</p><h4 id="unordered-multiset-哈希表"><a href="#unordered-multiset-哈希表" class="headerlink" title="unordered_multiset(哈希表)"></a>unordered_multiset(哈希表)</h4><p>篮子不能太长，如果元素的个数大于等于篮子，篮子就要重新扩充大于等于两倍的元素个数</p><h4 id="unordered-set-哈希表）"><a href="#unordered-set-哈希表）" class="headerlink" title="unordered_set (哈希表）"></a>unordered_set (哈希表）</h4><h3 id="四个容器区别总结"><a href="#四个容器区别总结" class="headerlink" title="四个容器区别总结"></a>四个容器区别总结</h3><p>set 和 multiset 是基于红黑树实现的关联容器，可以快速插入、删除、查找元素，并且元素默认按照元素值从小到大排序，但插入、删除和查找等操作的时间复杂度为 O(log n)。</p><p>unordered_set 和 unordered_multiset 是基于哈希表实现的关联容器，可以快速插入、删除、查找元素，并且插入、删除和查找等操作的时间复杂度为 O(1)，但元素没有固定的顺序。</p><p>在选择使用哪种容器时，需要考虑元素是否需要排序以及对性能的要求。如果元素需要排序，且对性能要求不是非常高，可以选择 set 或 multiset；如果对性能要求比较高，可以选择 unordered_set 或 unordered_multiset。</p><h4 id="四个容器的用法："><a href="#四个容器的用法：" class="headerlink" title="四个容器的用法："></a>四个容器的用法：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//1.定义</span><br><span class="line">std::set&lt;int&gt; s;</span><br><span class="line">std::multiset&lt;int&gt; ms;</span><br><span class="line">std::unordered_multiset&lt;int&gt; ums;</span><br><span class="line">std::unordered_set&lt;int&gt; us;</span><br><span class="line">//2.插入</span><br><span class="line">s.insert(5);</span><br><span class="line">s.insert(2);</span><br><span class="line">ms.insert(3);</span><br><span class="line">ms.insert(4);</span><br><span class="line">/*后面两个容器也一样*/</span><br><span class="line"></span><br><span class="line">//3.查找元素</span><br><span class="line">auto it = s.find(2);//返回的是迭代器指针</span><br><span class="line">std::cout &lt;&lt; *it;</span><br><span class="line">//4.遍历</span><br><span class="line">for (auto it = s.begin(); it != s.end(); ++it) &#123;</span><br><span class="line">	std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;; // 输出 set 容器中的元素</span><br><span class="line">&#125;</span><br><span class="line">for (auto it = ms.begin(); it != ms.end(); ++it) &#123;</span><br><span class="line">	std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;; // 输出 multiset 容器中的元素</span><br><span class="line">&#125;</span><br><span class="line">for (auto i : ms)</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; i&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">for (auto i : s)</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; i&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">//5.合并</span><br><span class="line">s.merge(ms);</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>Map是C++ STL中的一个关联式容器，它提供了一种映射关系的数据结构，即一组key-value对，其中key是唯一的，value可以重复。Map中的元素是按照key的大小进行排序的，因此可以进行快速的查找和插入操作。Map支持[]和insert等操作，可以通过迭代器进行遍历。Map的底层实现一般采用红黑树，因此它的插入、删除和查找操作的时间复杂度都是O(log n)。</p><p>用法：<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*插入，创建，初始化,修改*/</span><br><span class="line">	std::map&lt;std::string, int&gt; m&#123; &#123;&quot;CPU&quot;,10&#125; ,&#123;&quot;GPU&quot;,20&#125;&#125;;</span><br><span class="line">	m.insert(std::pair&lt;std::string, int&gt;(&quot;ARM&quot;, 35));//插入</span><br><span class="line">	m[&quot;ARM&quot;] = 45;</span><br><span class="line">	m[&quot;Map&quot;] = 15;//插入新值</span><br><span class="line"></span><br><span class="line">	/*遍历方法*/</span><br><span class="line">	for (const auto&amp; [key, value] : m)</span><br><span class="line">		std::cout &lt;&lt; &#x27;[&#x27; &lt;&lt; key &lt;&lt; &quot;] = &quot; &lt;&lt; value &lt;&lt; &quot;; &quot;;</span><br><span class="line"></span><br><span class="line">	for (auto it = m.begin(); it != m.end(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h3><p>Multimap是一个允许重复键的Map，它也是一个关联式容器，提供了一种映射关系的数据结构，其中一组key-value对中的key可以重复，而value可以不重复。Multimap的元素同样是按照key的大小进行排序的，并且支持[]和insert等操作，可以通过迭代器进行遍历。Multimap的底层实现一般采用红黑树，因此它的插入、删除和查找操作的时间复杂度也都是O(log n)。</p><p>用法：<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//2.multimap</span><br><span class="line">	std::multimap&lt;std::string, int&gt; m;</span><br><span class="line">	m.insert(std::pair&lt;std::string, int&gt;(&quot;map&quot;, 10));</span><br><span class="line">	m.insert(std::pair&lt;std::string, int&gt;(&quot;map&quot;, 10));</span><br><span class="line">	m.insert(std::pair&lt;std::string, int&gt;(&quot;map&quot;, 10));</span><br><span class="line">	//m[&quot;map&quot;] = 15;//没有[]操作符 error</span><br><span class="line">	for (auto it = m.begin(); it != m.end(); it++) &#123;</span><br><span class="line">		std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot; : &quot; &lt;&lt; it-&gt;second &lt;&lt;std:: endl;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><br>Multimap的用法和Map类似，只是插入操作不会覆盖已有的键值对。<p></p><h3 id="unordered-multimap"><a href="#unordered-multimap" class="headerlink" title="unordered_multimap"></a>unordered_multimap</h3><p>unordered_multimap是一个允许重复键的unordered_map，它也是一个哈希表，提供了一种映射关系的数据结构，其中一组key-value对中的key可以重复，而value可以不重复。unordered_multimap中的元素是按照哈希值进行存储的，因此查找和插入操作的时间复杂度是O(1)。</p><p>用法：<br>unordered_map的用法和Map类似，只是底层实现不同，插入操作的时间复杂度为O(1)。</p><h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><p>unordered_map是C++ STL中的一个哈希表，它提供了一种映射关系的数据结构，其中一组key-value对中的key是唯一的，而value可以重复。unordered_map中的元素是按照哈希值进行存储的，因此查找和插入操作的时间复杂度是O(1)。</p><p>用法：<br>unordered_multimap的用法和unordered_map类似，只是允许键值对中的键重复。</p><h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><p>Map和Multimap都是基于红黑树实现的，而unordered_map和unordered_multimap都是基于哈希表实现的。因此，Map和Multimap的插入、删除和查找操作的时间复杂度都是O(log n)，而unordered_map和unordered_multimap的插入、删除和查找操作的时间复杂度都是O(1)。另外，Map和Multimap中的元素是按照key的大小进行排序的，而unordered_map和unordered_multimap中的元素是按照哈希值进行存储的，因此它们的遍历顺序可能不同。此外，Multimap和unordered_multimap允许重复键，而Map和unordered_map不允许重复键。</p><h3 id="补充stl算法"><a href="#补充stl算法" class="headerlink" title="补充stl算法"></a>补充stl算法</h3><h4 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound"></a>upper_bound</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; v = &#123;1, 2, 3, 4, 4, 6, 7, 8, 9&#125;;</span><br><span class="line">  auto it = std::upper_bound(v.begin(), v.end(), 4);</span><br><span class="line">  if (it != v.end()) &#123;</span><br><span class="line">      std::cout &lt;&lt; &quot;The first element greater than 4 is: &quot; &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      std::cout &lt;&lt; &quot;No element greater than 4&quot; &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>std::upper_bound将返回一个迭代器，指向第一个大于value的元素。如果不存在这样的元素，std::upper_bound将返回last。</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://null0x0f.github.io">NULL+</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://null0x0f.github.io/posts/d99aa42e.html">https://null0x0f.github.io/posts/d99aa42e.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://null0x0f.github.io" target="_blank">NULL'blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/ccc5cd0f.html" title="设计模式期末"><div class="cover" style="background:var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">设计模式期末</div></div></a></div><div class="next-post pull-right"><a href="/posts/46594b90.html" title="GDB调试"><div class="cover" style="background:var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">GDB调试</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">NULL+</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/null0x0f"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/null0x0f" target="_blank"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">technical blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#cpp%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85"><span class="toc-number">1.</span> <span class="toc-text">cpp知识补充</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#namespace"><span class="toc-number">1.2.</span> <span class="toc-text">namespace</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B6%E5%B1%82const%E5%92%8C%E5%BA%95%E5%B1%82const"><span class="toc-number">1.3.</span> <span class="toc-text">顶层const和底层const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#register-%E5%8A%A0%E5%BC%BA"><span class="toc-number">1.4.</span> <span class="toc-text">register 加强</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%89%96%E6%9E%90"><span class="toc-number">1.5.</span> <span class="toc-text">引用剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AF%AD%E6%B3%95"><span class="toc-number">1.5.1.</span> <span class="toc-text">引用语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.5.2.</span> <span class="toc-text">引用本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%AF%E5%BC%95%E7%94%A8"><span class="toc-number">1.5.3.</span> <span class="toc-text">函数返回值是引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inline-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.</span> <span class="toc-text">inline 内联函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.</span> <span class="toc-text">构造函数和析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.7.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%86%E7%B1%BB"><span class="toc-number">1.7.2.</span> <span class="toc-text">构造函数分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.3.</span> <span class="toc-text">深拷贝和浅拷贝问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%88%86%E6%9E%90"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">浅拷贝分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E5%8F%B7%E6%93%8D%E4%BD%9C%E4%B9%9F%E6%98%AF%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">等号操作也是浅拷贝操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.8.</span> <span class="toc-text">临时对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.8.1.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.2.</span> <span class="toc-text">构造函数中调用构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-%E5%92%8Cdelete"><span class="toc-number">1.9.</span> <span class="toc-text">new 和delete</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">1.9.1.</span> <span class="toc-text">基本语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.10.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-number">1.10.1.</span> <span class="toc-text">友元函数和友元类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">友元函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-number">1.10.1.2.</span> <span class="toc-text">友元类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.10.1.3.</span> <span class="toc-text">重载运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.11.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.11.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E7%9A%84%E8%AF%AD%E6%B3%95%E5%92%8C%E6%A6%82%E5%BF%B5"><span class="toc-number">1.11.2.</span> <span class="toc-text">访问父类的语法和概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">1.11.3.</span> <span class="toc-text">派生类的访问控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84"><span class="toc-number">1.11.4.</span> <span class="toc-text">继承中构造和析构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.11.5.</span> <span class="toc-text">继承和虚函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="toc-number">1.11.6.</span> <span class="toc-text">复合和继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="toc-number">1.11.7.</span> <span class="toc-text">委托和继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="toc-number">1.12.</span> <span class="toc-text">抽象基类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">1.12.1.</span> <span class="toc-text">继承的动态内存分配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#conversion-function"><span class="toc-number">1.13.</span> <span class="toc-text">conversion function</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#non-explicit-one-argument-ctor"><span class="toc-number">1.13.0.1.</span> <span class="toc-text">non -explicit-one-argument ctor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#conversion-function-vs-non-explicit-one-argument-constructor"><span class="toc-number">1.13.0.2.</span> <span class="toc-text">conversion function vs. non-explicit-one-argument constructor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#explicit-one-argument-constructor"><span class="toc-number">1.13.0.3.</span> <span class="toc-text">explicit-one-argument constructor</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pointer-like-classes"><span class="toc-number">1.14.</span> <span class="toc-text">pointer like classes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">1.14.1.</span> <span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#shared-ptr"><span class="toc-number">1.14.1.1.</span> <span class="toc-text">shared_ptr</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.14.2.</span> <span class="toc-text">迭代器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fuction-like-classes"><span class="toc-number">1.15.</span> <span class="toc-text">fuction like classes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.15.1.</span><span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.16.</span> <span class="toc-text">模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.16.1.</span> <span class="toc-text">类模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.16.2.</span> <span class="toc-text">函数模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.16.3.</span> <span class="toc-text">成员模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96"><span class="toc-number">1.16.4.</span> <span class="toc-text">模板特化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%8F%E7%89%B9%E5%8C%96-%E5%B1%80%E9%83%A8%E7%89%B9%E5%8C%96"><span class="toc-number">1.16.5.</span> <span class="toc-text">偏特化(局部特化)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="toc-number">1.16.6.</span> <span class="toc-text">模板模板参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E4%B8%BB%E9%A2%98"><span class="toc-number">1.17.</span> <span class="toc-text">三个主题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pack"><span class="toc-number">1.17.1.</span> <span class="toc-text">pack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#auto"><span class="toc-number">1.17.2.</span> <span class="toc-text">auto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ranged-base-for"><span class="toc-number">1.17.3.</span> <span class="toc-text">ranged-base for</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reference"><span class="toc-number">1.18.</span> <span class="toc-text">reference</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this"><span class="toc-number">1.19.</span> <span class="toc-text">this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BDnew-delete"><span class="toc-number">1.20.</span> <span class="toc-text">重载new(),delete()</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#STL"><span class="toc-number">2.</span> <span class="toc-text">STL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#array"><span class="toc-number">2.1.1.</span> <span class="toc-text">array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector"><span class="toc-number">2.1.2.</span> <span class="toc-text">vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list"><span class="toc-number">2.1.3.</span> <span class="toc-text">list</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#forward-list"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">forward list</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#queue-%E5%AE%B9%E5%99%A8%E7%9A%84%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">2.1.4.</span> <span class="toc-text">queue(容器的适配器 )</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deque"><span class="toc-number">2.1.5.</span> <span class="toc-text">deque</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stack-%E5%AE%B9%E5%99%A8%E7%9A%84%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">2.1.6.</span> <span class="toc-text">stack(容器的适配器)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set-%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">2.1.7.</span> <span class="toc-text">set 红黑树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#multiset-%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">2.1.7.1.</span> <span class="toc-text">multiset(红黑树)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unordered-multiset-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">2.1.7.2.</span> <span class="toc-text">unordered_multiset(哈希表)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unordered-set-%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89"><span class="toc-number">2.1.7.3.</span> <span class="toc-text">unordered_set (哈希表）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E4%B8%AA%E5%AE%B9%E5%99%A8%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93"><span class="toc-number">2.1.8.</span> <span class="toc-text">四个容器区别总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E4%B8%AA%E5%AE%B9%E5%99%A8%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%9A"><span class="toc-number">2.1.8.1.</span> <span class="toc-text">四个容器的用法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map"><span class="toc-number">2.1.9.</span> <span class="toc-text">map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#multimap"><span class="toc-number">2.1.10.</span> <span class="toc-text">multimap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unordered-multimap"><span class="toc-number">2.1.11.</span> <span class="toc-text">unordered_multimap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unordered-map"><span class="toc-number">2.1.12.</span> <span class="toc-text">unordered_map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93"><span class="toc-number">2.1.13.</span> <span class="toc-text">区别总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85stl%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.14.</span> <span class="toc-text">补充stl算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#upper-bound"><span class="toc-number">2.1.14.1.</span> <span class="toc-text">upper_bound</span></a></li></ol></li></ol></li></ol></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/79666db.html" title="数据结构">数据结构</a><time datetime="2024-09-20T07:29:47.156Z" title="发表于 2024-09-20 07:29:47">2024-09-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/36dc4835.html" title="jsp_final">jsp_final</a><time datetime="2024-09-20T07:29:47.156Z" title="发表于 2024-09-20 07:29:47">2024-09-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/1db60101.html" title="OPERATING SYSTEM">OPERATING SYSTEM</a><time datetime="2024-09-20T07:29:47.156Z" title="发表于 2024-09-20 07:29:47">2024-09-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/ccc5cd0f.html" title="设计模式期末">设计模式期末</a><time datetime="2024-09-20T07:29:47.156Z" title="发表于 2024-09-20 07:29:47">2024-09-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/d99aa42e.html" title="c plus plus">c plus plus</a><time datetime="2023-04-24T11:22:45.000Z" title="发表于 2023-04-24 11:22:45">2023-04-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By NULL+</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><div class="app-refresh" id="app-refresh" style="position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease"><div class="app-refresh-wrap" style="display:flex;color:#fff;height:100%;align-items:center;justify-content:center"><label>✨ 有新文章啦！ 👉</label><a href="javascript:void(0)" onclick="location.reload()"><span style="color:#fff;text-decoration:underline;cursor:pointer">🍗点击食用🍔</span></a></div></div><script>if ('serviceWorker' in navigator) {
if (navigator.serviceWorker.controller) {
navigator.serviceWorker.addEventListener('controllerchange', function() {
showNotification()
})
}
window.addEventListener('load', function() {
navigator.serviceWorker.register('/sw.js')
})
}
function showNotification() {
if (GLOBAL_CONFIG.Snackbar) {
var snackbarBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
GLOBAL_CONFIG.Snackbar.bgLight :
GLOBAL_CONFIG.Snackbar.bgDark
var snackbarPos = GLOBAL_CONFIG.Snackbar.position
Snackbar.show({
text: '✨ 有新文章啦！ 👉',
backgroundColor: snackbarBg,
duration: 500000,
pos: snackbarPos,
actionText: '🍗点击食用🍔',
actionTextColor: '#fff',
onActionClick: function(e) {
location.reload()
},
})
} else {
var showBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
'#3b70fc' :
'#1f1f1f'
var cssText = `top: 0; background: ${showBg};`
document.getElementById('app-refresh').style.cssText = cssText
}
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script data-pjax>function butterfly_clock_anzhiyu_injector_config(){var e=document.getElementsByClassName("sticky_layout")[0];console.log("已挂载butterfly_clock_anzhiyu"),e&&e.insertAdjacentHTML("afterbegin",'<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.6/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>')}for(var elist="null".split(","),cpage=location.pathname,epage="all",qweather_key="43d2913d6dec46aa9571ee8d72878f8d",gaud_map_key="563a959d007d0f2c5167053ad5e9a910",baidu_ak_key="undefined",flag=0,clock_rectangle="112.6534116,27.96920845",clock_default_rectangle_enable="false",i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;"all"===epage&&0==flag?butterfly_clock_anzhiyu_injector_config():epage===cpage&&butterfly_clock_anzhiyu_injector_config()</script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.6/lib/clock.min.js"></script><script async src="/js/ali_font.js"></script><div class="js-pjax"><script async>for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration","1.5s"),arr[i].setAttribute("data-wow-delay","200ms"),arr[i].setAttribute("data-wow-offset","30"),arr[i].setAttribute("data-wow-iteration","1")</script><script async>for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay","200ms"),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("flink-list-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__flipInY"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("flink-list-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__animated"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("article-sort-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__slideInRight"),arr[i].setAttribute("data-wow-duration","1.5s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("site-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__flipInY"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("site-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__animated"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax src="https://cdn.cbd.int/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>function gitcalendar_injector_config(){document.getElementById("recent-posts").insertAdjacentHTML("afterbegin",'<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 280px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>'),console.log("已挂载gitcalendar")}document.getElementById("recent-posts")&&"/"===location.pathname&&(gitcalendar_injector_config(),GitCalendarInit("https://vercel-3o3l.vercel.app/api/?null0x0f/api?null0x0f",["#e4dfd7","#f9f4dc","#f7e8aa","#f7e8aa","#f8df72","#fcd217","#fcc515","#f28e16","#fb8b05","#d85916","#f43e06"],"null0x0f"))</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/koharu.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!1},log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/"})</script></body></html>